\input texinfo   @c -*- mode: texinfo -*-

@c *****************************************************************************
@c %**start of header (This is for running Texinfo on a region.)

@setfilename  Clojure-Lang.info
@settitle     Clojure Language Reference
@include      my-bib-macros.texi
@mybibusetable{Bibliography}

@c %**end of header (This is for running Texinfo on a region.)
@c *****************************************************************************

@c VERSION 0.0.9
@c DATE    2018-10-3121:00

@c *****************************************************************************
@c DOCUMENT VARIABLES
@c *****************************************************************************

@c -----------------------------------------------------------------------------
@set TITLE      Clojure Language Reference
@set SHORTTITLE Clojure Lang
@set EDITION 0.1
@set UPDATE-MONTH OCTOBER, 2018 @c goes in the subtitle
@set AUTHOR WLHarvey4
@set ADDRESS1 Address Line 1
@set ADDRESS2 Address Line 2
@set COPYRIGHT 2018
@c -----------------------------------------------------------------------------




@c *****************************************************************************
@c FINALOUT / DRAFT / FORPRINT
@c *****************************************************************************

@c -----------------------------------------------------------------------------
@set      DRAFT @i{DRAFT} @c when set, print DRAFT in heading
@c @clear DRAFT  @c when clear, don't print DRAFT in heading
@clear  FINALOUT @c when clear, show black boxes for overfull lines
@c @set FINALOUT @c when set, don't show black boxes for overfull lines
@clear  FORPRINT @c when clear, PDF output is for viewing, not printing
@c @set FORPRINT @c when set, PDF output is for printing, not viewing

@iftex
@ifset FINALOUT @c don't show black boxes for final printout
@finalout
@end ifset
@end iftex

@c Uncomment this for the release.  Leaving it off saves paper
@c during editing and review.
@ifset FORPRINT
@ifset FINALOUT
@c @setchapternewpage odd
@end ifset
@end ifset

@ifclear FORPRINT
@pdflinkcolor
@urllinkcolor
@hideurls
@end ifclear
@c -----------------------------------------------------------------------------




@c *****************************************************************************
@c SECTIONING
@c *****************************************************************************

@c -----------------------------------------------------------------------------
@iftex
@set DOCUMENT book
@set CHAPTER chapter
@set APPENDIX appendix
@set SECTION section
@set SUBSECTION subsection
@end iftex
@ifhtml
@set DOCUMENT Web page
@set CHAPTER chapter
@set APPENDIX appendix
@set SECTION section
@set SUBSECTION subsection
@end ifhtml
@ifinfo
@set DOCUMENT Info file
@set CHAPTER major node
@set APPENDIX major node
@set SECTION minor node
@set SUBSECTION node
@end ifinfo
@ifdocbook
@set DOCUMENT book
@set CHAPTER chapter
@set APPENDIX appendix
@set SECTION section
@set SUBSECTION subsection
@end ifdocbook
@c -----------------------------------------------------------------------------




@c *****************************************************************************
@c SPECIAL TEXIWEBJR COMMANDS
@c *****************************************************************************

@c -----------------------------------------------------------------------------
@c Change how xref titles are quoted.
@dquotexrefs
@c And let braces in index entries work.
@allowindexbraces

@c some special symbols
@ifnottex
@macro ii{text}
@i{\text\}
@end macro
@end ifnottex
@c -----------------------------------------------------------------------------




@c *****************************************************************************
@c INDEX COMMANDS
@c *****************************************************************************(

@c merge the function and variable indexes into the concept index
@c do so without the code font, and in the index entries do the
@c font management ourselves.  Also merge in the chunk definition
@c and reference entries, which jrweave creates for us.
@ifnothtml
@synindex fn cp
@synindex vr cp
@synindex cd cp
@synindex cr cp
@end ifnothtml




@c *****************************************************************************
@copying
@c *****************************************************************************

@ -----------------------------------------------------------------------------
@docbook
<para>Published by:</para>

<literallayout class="normal">Full Name
Address Line 1
Address Line 2
etc.
Email: <email>user@@example.com</email>
URL: <ulink url="http://www.example.com/">http://www.example.com/</ulink></literallayout>

<literallayout class="normal">Copyright &copy; YYYY, YYYY
Full name here
All Rights Reserved.</literallayout>
@end docbook
@c -----------------------------------------------------------------------------


@c -----------------------------------------------------------------------------
@ifnotdocbook
Copyright @copyright{} @value{COPYRIGHT} @*
@value{AUTHOR} @*
All Rights Reserved.
@end ifnotdocbook
@c -----------------------------------------------------------------------------


@sp 1
The @value{TITLE} is copyright
@copyright{} @value{COPYRIGHT} by @value{AUTHOR}. It is published under
the conditions of the GNU General Public License, version 3.
@sp 2
This is Edition @value{EDITION} of @cite{@value{TITLE}}.

@end copying
@c /////////////////////////////////////////////////////////////////////////////




@c =============================================================================
@titlepage
@c =============================================================================

@c Uncomment this if it's ever printed as a real book(let).
@c @shorttitlepage @value{SHORTTITLE}

@title @value{TITLE}
@subtitle @value{UPDATE-MONTH}
@author @value{AUTHOR} @c Full Name here

@ifnotdocbook
@c Include the Distribution inside the titlepage environment so
@c that headings are turned off.  Headings on and off do not work.

@page
@vskip 0pt plus 1filll
Published by:
@sp 1
@value{AUTHOR} @*
@value{ADDRESS1} @*
@value{ADDRESS2} @*
@* @c etc.
Email: @EMAIL{user@@example.com,user AT example.com} @*
URL: @url{http://www.example.com/} @*

@insertcopying
@end ifnotdocbook

@end titlepage
@c /////////////////////////////////////////////////////////////////////////////



@c *****************************************************************************
@c HEADINGS
@c *****************************************************************************

@iftex
@headings off
@evenheading @thispage @| @value{DRAFT} @| @strong{@value{SHORTTITLE}}
@oddheading  @strong{@thischapter} @| @value{DRAFT} @| @thispage
@end iftex








@c #############################################################################
@c BEGIN
@c #############################################################################








@ifnottex
@ifnotdocbook
@ifnotxml

@c =============================================================================
@node Top
@top The CLOJURE Programming Language
@c =============================================================================

@c Preface node should come right after the Top
@c node, in `unnumbered' sections, then the introductory chapter.
@c Licensing nodes are appendices, they're not central to TexiWebJr.

This  file documents  the programming  language CLOJURE,  and provides  example
source code that can be extracted and run.

@quotation
clojure: warning: Your terminal 'dumb' is not fully functional, expect some
problems.
@end quotation


@insertcopying
@end ifnotxml
@end ifnotdocbook
@end ifnottex




@c =============================================================================
@menu
@detailmenu
@end detailmenu
@end menu
@c =============================================================================




@c =============================================================================
@c @summarycontents
@contents
@c =============================================================================








@c *****************************************************************************

@c Add these to the menu if they ever get included.
@c @node Foreword
@c @unnumbered Foreword








@c *****************************************************************************

@node Preface
@unnumbered Preface

Text here.

@menu
* Audience::                    Who should read this @value{DOCUMENT}.
* Overview::                    An overview of the @value{DOCUMENT}.
* Conventions::                 Typographical conventions.
* Acknowledgements::            Acknowledgements.
@end menu




@c -----------------------------------------------------------------------------
@node Audience
@unnumberedsec Intended Audience

Audience text here.




@c -----------------------------------------------------------------------------
@node Overview
@unnumberedsec What Is Covered

Overview text and chapter by chapter description here.




@c -----------------------------------------------------------------------------
@node Conventions
@unnumberedsec Typographical Conventions

@c Copied mostly verbatim from the gawk manual.

@cindex Texinfo document formatting language
This @value{DOCUMENT} is written in an enhanced version of
@uref{http://www.gnu.org/software/texinfo/, Texinfo},
the GNU documentation formatting language.
A single Texinfo source file is used to produce both the printed and online
versions of a program's documentation.
@ifnotinfo
Because of this, the typographical conventions
are slightly different than in other books you may have read.
@end ifnotinfo

Examples you would type at the command-line are preceded by the common
shell primary and secondary prompts, @samp{$} and @samp{>}.  Input that
you type is shown @kbd{like this}.  Output from the command is preceded
by the glyph ``@print{}''.  This typically represents the command's
standard output.  Error messages, and other output on the command's
standard error, are preceded by the glyph ``@error{}''.  For example:

@example
$ @kbd{echo hi on stdout}
@print{} hi on stdout
$ @kbd{echo hello on stderr 1>&2}
@error{} hello on stderr
@end example

@ifnotinfo
In the text, command names appear in @code{this font}, while code segments
appear in the same font and quoted, @samp{like this}.  Options look
like this: @option{-f}.  Some things are emphasized @emph{like this},
and if a point needs to be made strongly, it is done @strong{like this}.
The first occurrence of a new term is usually its @dfn{definition} and
appears in the same font as the previous occurrence of ``definition''
in this sentence.  Finally, file names are indicated like this:
@file{/path/to/our/file}.
@end ifnotinfo




@c -----------------------------------------------------------------------------
@node Acknowledgements
@unnumberedsec Acknowledgements

Acknowledgements go here.




@c /////////////////////////////////////////////////////////////////////////////
@c END Preface








@c *****************************************************************************
@node Introduction
@chapter Introduction

CLOJURE's home page is at: @url{https://clojure.org/index}.

The home site describes CLOJURE as:

@quotation
Clojure is  a robust, practical,  and fast programming  language with a  set of
useful features that together form a simple, coherent, and powerful tool.

Clojure  is  a dynamic,  general-purpose  programming  language, combining  the
approachability and  interactive development  of a  scripting language  with an
efficient and robust infrastructure  for multithreaded programming.  Clojure is
a compiled language, yet remains completely dynamic –-- every feature supported
by Clojure is  supported at runtime.  Clojure provides easy  access to the Java
frameworks, with optional  type hints and type inference, to  ensure that calls
to Java can avoid reflection.

Clojure is a dialect of Lisp,  and shares with Lisp the code-as-data philosophy
and a powerful macro system.  Clojure is predominantly a functional programming
language,   and   features  a   rich   set   of  immutable,   persistent   data
structures.  When   mutable  state  is   needed,  Clojure  offers   a  software
transactional  memory  system and  reactive  Agent  system that  ensure  clean,
correct, multithreaded designs.

@end quotation

@heading Important Ideas

@itemize
@item Practical
@item General Purpose
@item Scripting Language
@item Multithreaded Programming
@item Compiled Language
@item Dynamic Language
@item Java Frameworks
@item Type Hints / Type Inference
@item Dialect of Lisp
@item Code-As-Data
@item Macro System
@item Immutable Data Structure
@item Transactional Memory System / Reactive Agent System
@end itemize




@c -----------------------------------------------------------------------------

@node Rationale for Clojure
@section Rationale for Clojure

@heading Rationale

CLOJURE provides the following features (benefits):

@itemize
@item it is LISP
@item it is FUNCTIONAL
@item symbiotic with the JVM
@item supports CONCURRENCY
@end itemize

@heading Rationale In Detail

@itemize
@item Stakeholders want the JVM

Customers and stakeholders have substantial investments in, and are comfortable
with the  performance, security  and stability of,  industry-standard platforms
like the JVM.

@item Stakeholders envy dynamic languages

Java developers @dots{} envy the  succinctness, flexibility and productivity of
dynamic languages;

@item Problems with concurrency

they face  ongoing problems dealing  with concurrency using native  threads and
locking.

@item Clojure addresses these concerns

Clojure is an effort in pragmatic  dynamic language design in this context.  It
endeavors to be  a general-purpose language suitable in those  areas where Java
is  suitable.  It  reflects the  reality that,  for the  concurrent programming
future, pervasive, unmoderated mutation simply has to go.

@item Clojure runs on the JVM

Clojure meets its  goals by: embracing an industry-standard,  open platform ---
the JVM;

@item CLOJURE is LISP

modernizes a venerable language - Lisp;

@item uses functional programming and immutable data

fosters  the functional  programming paradigm  with immutable,  persistent data
structures;

@item has concurrency support

and provides built-in  concurrency support  via software transactional  memory and
asynchronous agents.

@item CLOJURE IS:

robust --- practical --- fast

@end itemize




@c -----------------------------------------------------------------------------

@node Dynamic Functional Lisp
@section CLOJURE Is Dynamic Functional Lisp

CLOJURE is  a Lisp  not constrained  by backwards compatibility;  it is  also a
functional language supporting  immutability that is not  constrained by static
typing or homogeneous collections.

@itemize
@item
Extends the code-as-data paradigm to maps and vectors
@item
Defaults to immutability
@item
Core data structures are extensible abstractions
@item
Embraces a platform (JVM)
@item
Clojure is a functional language with a dynamic emphasis
@item
All data structures immutable & persistent, supporting recursion
@item
Heterogeneous collections, return types
@item
Dynamic polymorphism
@end itemize




@c -----------------------------------------------------------------------------

@node Clojure Features
@section Clojure Features
@cindex features

Clojure has a set of useful features that together form a simple, coherent, and
powerful tool.


@c .....................................

@node Dynamic Development
@subsection Dynamic Development
@cindex dynamic

First and foremost,  Clojure is dynamic.  That means that  a Clojure program is
not  just something  you compile  and  run, but  something with  which you  can
interact.  Almost all  of the language constructs are reified,  and thus can be
examined and changed.

This  leads to  a substantially  different experience  from running  a program,
examining its results  (or failures) and trying again.  In  particular, you can
grow your program, with data loaded,  adding features, fixing bugs, testing, in
an unbroken stream.

@subheading The REPL
@cindex REPL

While Clojure  can be embedded  in a Java application,  or used as  a scripting
language, the primary programming interface is the Read-Eval-Print-Loop (REPL).
You can  start the  Clojure REPL like  this, and then  follow along  trying the
samples in this feature tour:

@example
java -cp clojure.jar clojure.main
@end example

Clojure has arbitrary precision integers, strings, ratios, doubles, characters,
symbols, keywords.

@cindex compiler
@cindex JVM bytecode
While  Clojure is  a  compiled language,  you don't  ``run''  the compiler  ---
anything  you enter  into the  REPL or  load using  load-file is  automatically
compiled to JVM bytecode on the fly.


@c .....................................

@node Functional Programming
@subsection Functional Programming
@cindex functional

Clojure is  a functional programming language.  It:

@itemize
@item
provides the tools to avoid mutable state,
@item
provides  functions  as first-class  objects,  and
@item
emphasizes recursive iteration instead of side-effect based looping.
@end itemize

The philosophy  behind Clojure is  that most parts  of most programs  should be
functional, and that programs that are more functional are more robust.

@subheading First Class Functions
@cindex @code{fn}
@cindex @code{defn}
@cindex macro
@cindex function object

@code{fn} creates a function object.  It yields  a value like any other --- you
can store it in a var, pass it to functions etc.

@example
(def hello (fn [] "Hello world"))
@end example

@code{defn} is a macro that makes defining functions a little simpler.  Clojure
supports arity  overloading in  a single  function object,  self-reference, and
variable-arity functions using @code{&}:

@example
(defn argcount
  ([] 0)
  ([x] 1)
  ([x y] 2)
  ([x y & more] (+ (argcount x y) (count more))))
@end example

@cindex @code{let}
You can create local names for  values inside a function using @code{let}.  The
scope of any local names is lexical.

@subheading Immutable Data Structures
@cindex data structures, immutable
@cindex immutable data structures

The  easiest   way  to  avoid   mutating  state   is  to  use   immutable  data
structures.  Clojure provides a set of immutable

@itemize
@item lists,
@item vectors,
@item sets and
@item maps.
@end itemize

@cindex persistence
Since they can’t be changed, 'adding' or 'removing' something from an immutable
collection means creating a  new collection just like the old  one but with the
needed  change.  @dfn{Persistence}  is a  term  used to  describe the  property
wherein  the  old version  of  the  collection  is  still available  after  the
'change', and that the collection maintains its performance guarantees for most
operations.   Singly-linked  lists and  trees  are  the basic  functional  data
structures, to which  Clojure adds a hash  map, set and vector  both based upon
array mapped hash tries.

@subsubheading Metadata
@cindex metadata

Applications often need to associate attributes  and other data about data that
is  orthogonal to  the  logical value  of the  data.   Clojure provides  direct
support for  this metadata.   Symbols, and  all of  the collections,  support a
metadata map.   It can be accessed  with the meta function.   Metadata does not
impact equality semantics, nor will metadata be seen in operations on the value
of a collection.  Metadata can be read, and can be printed.

@subheading Extensible Abstractions
@cindex java interfaces

Clojure uses  Java interfaces to define  its core data structures.  This allows
for extensions of Clojure to  new concrete implementations of these interfaces,
and  the library  functions will  work  with these  extensions.  This  is a  big
improvement vs.  hardwiring a language  to the concrete implementations  of its
data types.

@subsubheading Seq Interface
@cindex seq interface

A good  example of this  is the  seq interface.  By  making the core  Lisp list
construct into  an abstraction, a wealth  of library functions are  extended to
any data  structure that can  provide a  sequential interface to  its contents.
All of  the Clojure data  structures can provide seqs.   Seqs can be  used like
iterators or generators.   Seqs are extremely simple,  providing a @code{first}
function,  which return  the  first item  in the  sequence,  and a  @code{rest}
function which returns the  rest of the sequence, which is  itself either a seq
or nil.

@subheading Recursive Looping

In the  absence of mutable local  variables, looping and iteration  must take a
different form than in languages with built-in for or while constructs that are
controlled by  changing state.  In  functional languages looping  and iteration
are replaced/implemented via recursive function calls.


@c .....................................

@node Dialect of Lisp
@subsection Dialect of Lisp
@cindex dialect of Lisp

Clojure  is a  member of  the  Lisp family  of languages.   Lisp’s approach  to
code-as-data and its macro system@footnote{The  macro system allows the compile
to be extended by user code.} still set it apart from other languages.  Clojure
extends the  code-as-data system beyond parenthesized  lists (s-expressions) to
vectors and  maps.  Thus  vectors and  maps can  be used  in macro  syntax, have
literal reader representations etc.

@heading The Reader and Macros

@cindex reader
Lisp  data, and  thus Lisp  code,  is read  by the  @dfn{reader}.@footnote{Most
Clojure programs begin life as text files, and  it is the task of the reader to
parse the text and  produce the data structure the compiler  will see.  This is
not  merely a  phase of  the  compiler.}  The  result  of reading  is the  data
structure represented by  the forms.  Clojure can compile  data structures that
represent code, and as part of that process it looks for calls to macros.  When
it sees  one, it calls  the macro, passing  the forms themselves  as arguments,
then uses  the return value of  the macro in  place of the macro  itself.  Thus
macros are functions that are called at compile time to perform transformations
of code.

@heading Syntactic Abstractions

Since code is  data, all of the  Clojure library is available to  assist in the
transformation.  Thus  macros allow  Lisps, and  Clojure, to  support syntactic
abstraction.  You  use macros  for the  same reasons you  use functions  --- to
eliminate repetition  in your code.   Macros should be reserved  for situations
for which functions are insufficient, e.g. when you need to control evaluation,
generate  identifiers etc.   Many of  the core  constructs of  Clojure are  not
built-in primitives but macros just like users can define.

@code{and} is a macro:

@example
(defmacro and
  ([] true)
  ([x] x)
  ([x & rest]
    `(let [and# ~x]
       (if and# (and ~@@rest) and#))))
@end example


@c .....................................

@node Runtime Polymorphism
@subsection Runtime Polymorphism

Systems  that   utilize  runtime   polymorphism  are   easier  to   change  and
extend. Clojure supports polymorphism in several ways:

@itemize
@item @emph{Java Interfaces}.
Most core infrastructure data structures in the Clojure runtime are defined by
Java interfaces.
@item @emph{Proxy}.
Clojure  supports  the generation  of  implementations  of Java  interfaces  in
Clojure using proxy
@item @emph{Multimethods}.
The  Clojure  language  supports  polymorphism  along  both  class  and  custom
hierarchies with multimethods.
@item @emph{Protocols}.
The Clojure language also supports a faster form of polymorphism with protocols.
@end itemize

@heading Multimethods
@cindex multimethods

Clojure  multimethods  are   a  simple  yet  powerful   mechanism  for  runtime
polymorphism that is free of the trappings of OO, types and inheritance.

@subheading Dispatch
@cindex dispatch
@cindex runtime polymorphism

The basic idea behind runtime polymorphism is that a single function designator
dispatches to  multiple independently-defined  function definitions  based upon
some  value of  the call.   For traditional  single-dispatch OO  languages that
value is the type of the 'receiver' or 'this'.

@subheading CLOS Functions
@cindex CLOS
@cindex multimethods

CLOS generic  functions extend  dispatch value  to a composite  of the  type or
value of multiple arguments, and are thus @dfn{multimethods}.

@subheading Arbitrary Function of Arguments
@cindex implementation inheritance

Clojure multimethods  go further still  to allow the  dispatch value to  be the
result of  an arbitrary  function of  the arguments.   Clojure does  not support
implementation inheritance.

@subheading Defining Multimethods
@cindex multimethods, defining
@cindex @code{defmulti}
@cindex @code{defmethod}

Multimethods are  defined using  @code{defmulti}, which takes  the name  of the
multimethod and the dispatch function.  Methods are independently defined using
@code{defmethod},  passing the  multimethod name,  the dispatch  value and  the
function body.

@heading Protocols
@cindex protocols

Similar to  interfaces, Clojure  protocols define only  function specifications
(no  implementation)   and  allow   types  to  implement   multiple  protocols.
Additionally,  protocols are  open to  later dynamic  extension for  new types.
Protocols are limited just  to dispatch on class type to  take advantage of the
native Java performance of polymorphic method calls.


@c .....................................

@node Concurrent Programming
@subsection Concurrent Programming
@cindex concurrent programming

Today’s systems  have to  deal with  many simultaneous  tasks and  leverage the
power of multi-core  CPUs. Doing so with  threads can be very  difficult due to
the   complexities  of   synchronization.  Clojure   simplifies  multi-threaded
programming in several ways.

@enumerate
@item Immutable Data.
Because the  core data  structures are  immutable, they  can be  shared readily
between threads.
@item State Changes.
However, it  is often necessary  to have state  change in a  program.  Clojure,
being a  practical language, allows state  to change but provides  mechanism to
ensure  that,  when  it  does  so, it  remains  consistent,  while  alleviating
developers from having to avoid conflicts manually using locks etc.
@item Software Transactional Memory System
The software transactional memory  system (STM), exposed through @code{dosync},
@code{ref},  @code{ref-set}, @code{alter},  et  al,  supports sharing  changing
state between threads in a synchronous and coordinated manner.
@item Agent System.
The  agent  system  supports  sharing  changing state  between  threads  in  an
asynchronous and independent manner.
@item Atoms System.
The  atoms  system  supports  sharing   changing  state  between  threads  in  a
synchronous and independent manner.
@item Dynamic Var System.
The  dynamic var  system, exposed  through @code{def},  @code{binding}, et  al,
supports isolating changing state within threads.
@item The Java Thread System.
IUn all cases, Clojure does not replace the Java thread system; rather it works
with it.  Clojure functions are @file{java.util.concurrent.Callable}U,
therefore they work with the @file{Executor} framework etc.
@item Refs.
Refs are  mutable references  to objects.   They can be  ref-set or  altered to
refer  to  different  objects  during  transactions,  which  are  delimited  by
@code{dosync} blocks.  All ref modifications within a transaction happen or none
do.

Also, reads  of refs within a  transaction reflect a snapshot  of the reference
world at  a particular point in  time, i.e.  each transaction  is isolated from
other  transactions.  If  a conflict  occurs between  2 transactions  trying to
modify the  same reference, one  of them will be  retried.  All of  this occurs
without explicit locking.
@end enumerate


@c .....................................

@node Hosted On The JVM
@subsection Hosted On The JVM

Clojure is designed to  be a hosted language, sharing the  JVM type system, GC,
threads etc.   It compiles all functions  to JVM bytecode.  Clojure  is a great
Java library  consumer, offering  the dot-target-member  notation for  calls to
Java.  Class names  can be referenced in full, or  as non-qualified names after
being imported.  Clojure supports the dynamic implementation of Java interfaces
and classes using reify and proxy:

Tapping into a Java class is as easy as:

@example
(import '[java.time LocalDate])

(defn add-week ^LocalDate [^LocalDate date]
  (.plusDays date 7))

(defn day->str [^LocalDate date]
  (format "%s %s, %s" (.getMonth date) (.getDayOfMonth date) (.getYear date)))

;; infinite sequence of weekly dates, starting from today
(def future-weeks (iterate add-week (LocalDate/now)))

(map day->str (take 4 future-weeks))
;; ("JULY 24, 2017" "JULY 31, 2017" "AUGUST 7, 2017" "AUGUST 14, 2017")
@end example




@c -----------------------------------------------------------------------------

@node Other Hosts
@section Other Hosts


@c .....................................

@node ClojureScript
@subsection ClojureScript
@cindex clojurescript

@url{https://clojurescript.org/, ClojureScript}

@cindex Google Closure optimizing compiler
ClojureScript  is a  compiler for  Clojure that  targets JavaScript.   It emits
JavaScript code which  is compatible with the advanced compilation  mode of the
Google Closure  optimizing compiler.  ClojureScript  combines the reach  of the
JavaScript platform,  the flexibility  and interactive development  of Clojure,
and  the whole-program  optimization  of  Google Closure  to  provide the  most
powerful language for programming the web.

@heading Why JavaScript?

The spread  of the browser and  web-based applications has given  JavaScript an
exclusive reach  unmatched by any  other language.  Because of  its importance,
JavaScript  engines  are also  receiving  extensive  research and  optimization
allowing  JavaScript to  compete  for performance  with  many more  established
platforms like the JVM.

@heading Why Google Closure?

As  the  purveyors   of  some  of  the  most   complicated  client-service  web
applications in use today, Google has  invested heavily in creating the Closure
library  and  Closure  compiler  which  work together  to  make  whole  program
optimization possible, yielding  programs that provide minimal  load times even
when using many libraries.


@c .....................................

@node Closure CLR
@subsection Closure CLR

@url{https://clojure.org/about/clojureclr, ClosureCLR}

@heading About

This  project is  a native  implementation of  Clojure on  the Common  Language
Runtime (CLR), the execution engine  of Microsoft’s .Net Framework.  ClojureCLR
is programmed in  C# (and Clojure itself) and makes  use of Microsoft’s Dynamic
Language Runtime (DLR).








@c *****************************************************************************

@node Getting Started
@chapter Getting Started
@cindex getting started




@c -----------------------------------------------------------------------------

@node New To Clojure
@section New To Clojure

New to Clojure  and not sure where to  start? Here are a few  good resources to
get you off on the right foot:

@itemize
@item
@url{https://changelog.com/posts/rich-hickeys-greatest-hits/,
Rich Hickey's Greatest Hits}

@item
@url{http://www.braveclojure.com/,
Clojure For The Brave And True}

@item
@url{http://aphyr.com/posts/301-clojure-from-the-ground-up-welcome,
Clojure From The Ground Up}

@xref{Clojure From The Ground Up}

@item
@url{http://4clojure.org/,
4Clojure (Learn Clojure Interactively)}

@item
@url{http://clojurescriptkoans.com/,
ClojureScript Koans}

@item
@url{https://repl.it/languages/clojure,
Run Clojure Code In Your Browser}

@end itemize




@c -----------------------------------------------------------------------------

@node CLI Guide
@section CLI Guide
@cindex CLI Guide

Clojure provides command line  tools that can be used to  start a Clojure repl,
use Clojure and Java libraries, and start Clojure programs.

@itemize
@item
Running an interactive REPL (Read-Eval-Print Loop)
@item
Running Clojure programs
@item
Evaluating Clojure expressions
@item
using Clojure and Java libraries
@end itemize


@c .....................................


@node Installing CLI Tools
@subsection Installing CLI Tools
@cindex install cli tools
@cindex command line tools
@cindex cli tools

@heading Initial Self-Configuration

After  installing Clojure  via  HomeBrew,  the first  time  I  ran the  command
@command{clojure} from Bash prompt, this occurred:

@verbatim
>>>[532]pine:Pine ~/Dev/Programming/Languages/Clojure
?clojure
Downloading: org/clojure/clojure/1.9.0/clojure-1.9.0.pom from https://repo1.maven.org/maven2/
Downloading: org/clojure/spec.alpha/0.1.143/spec.alpha-0.1.143.pom from https://repo1.maven.org/maven2/
Downloading: org/clojure/pom.contrib/0.2.2/pom.contrib-0.2.2.pom from https://repo1.maven.org/maven2/
Downloading: org/clojure/core.specs.alpha/0.1.24/core.specs.alpha-0.1.24.pom from https://repo1.maven.org/maven2/
Downloading: org/clojure/clojure/1.9.0/clojure-1.9.0.jar from https://repo1.maven.org/maven2/
Downloading: org/clojure/spec.alpha/0.1.143/spec.alpha-0.1.143.jar from https://repo1.maven.org/maven2/
Downloading: org/clojure/core.specs.alpha/0.1.24/core.specs.alpha-0.1.24.jar from https://repo1.maven.org/maven2/
Clojure 1.9.0
user=>
@end verbatim

@heading Leiningen Initialization

After installing Leiningen via HomeBrew, the first time I ran the command
@command{lein repl}, this occurred:

@verbatim
?lein repl
Retrieving org/clojure/tools.nrepl/0.2.12/tools.nrepl-0.2.12.pom from central
Retrieving org/clojure/pom.contrib/0.1.2/pom.contrib-0.1.2.pom from central
Retrieving org/sonatype/oss/oss-parent/7/oss-parent-7.pom from central
Retrieving clojure-complete/clojure-complete/0.2.4/clojure-complete-0.2.4.pom from clojars
Retrieving org/clojure/tools.nrepl/0.2.12/tools.nrepl-0.2.12.jar from central
Retrieving clojure-complete/clojure-complete/0.2.4/clojure-complete-0.2.4.jar from clojars
nREPL server started on port 60559 on host 127.0.0.1 - nrepl://127.0.0.1:60559
REPL-y 0.3.7, nREPL 0.2.12
Clojure 1.8.0
Java HotSpot(TM) 64-Bit Server VM 11+28
    Docs: (doc function-name-here)
          (find-doc "part-of-name-here")
  Source: (source function-name-here)
 Javadoc: (javadoc java-object-or-class-here)
    Exit: Control+D or (exit) or (quit)
 Results: Stored in vars *1, *2, *3, an exception in *e

user=>
@end verbatim


@c .....................................

@node Build Tools
@subsection Build Tools
@cindex build tools

Build  tools  provide  a  range  of capabilities  for  building,  running,  and
deploying  Clojure libraries  and applications.  The two  most popular  Clojure
build tools are

@itemize
@item @url{https://leiningen.org/, Leiningen}
@item @url{http://boot-clj.com/, Boot}
@end itemize


@c .....................................

@node Run a REPL
@subsection Run a REPL
@cindex REPL
@cindex run a Clojure REPL
@cindex run REPL
@cindex Clojure, run
@cindex @command{clj} tool

@heading REPL

After you download and  install the tools, you can start a  REPL by running the
@command{clj} tool:

@example
$ clj
Clojure 1.9.0
user=>
@end example

Once in the REPL  you can type Clojure expressions and  press enter to evaluate
them.


@c .....................................

@node Working With Deps
@subsection Working With Dependencies (Deps)
@cindex deps
@cindex dependencies
@cindex library
@cindex libraries, using
@cindex Java libraries
@cindex Maven ecosytem
@cindex Maven Central
@cindex program, run
@cindex Clojars

In  all the  above scenarios  you  might want  to  use other  Clojure and  Java
libraries (@dfn{dependencies} or  @dfn{deps}).  These may be  libraries you are
writing  locally, projects  in git  (e.g.  on GitHub)  or, commonly,  libraries
available in the Maven ecosystem and  hosted by central repositories like Maven
Central or Clojars.

In all cases, using a library involves:
@cindex how to use a library

@enumerate a
@item
specifying which library you want to  use, providing its name and other aspects
like version (using a @file{deps.edn} file)
@item
getting it (once) from the git or maven repositories to your local machine
@item
making it available on the JVM classpath so Clojure can find it while your REPL
or program is running
@end enumerate

@cindex @file{deps.edn}
Clojure tools specify a syntax and  file (@file{deps.edn}) for (a), given which
they’ll handle (b) and (c) automatically.

@heading Using A Clojure Or Java Library

There are  many Clojure  and Java  libraries available  that provide  access to
practically  any  functionality you  might  need.   For example,  consider  the
commonly used Clojure library @file{clj-time} for working with dates and times.

@subheading Declaring Dependencies
@cindex dependencies, declaring

To work with this  library, you need to declare it as a  dependency so the tool
can ensure it  has been downloaded and  added to the classpath.   The readme in
most projects shows  the name and version, such  as @code{[clj-time "0.14.2"]}.
Create a @file{deps.edn} file to declare the dependency:

@subsubheading @file{deps.edn}
@cindex @file{deps.edn}

@example
@{:deps
 @{clj-time @{:mvn/version "0.14.2"@}@}@}
@end example

Restart the REPL with the @command{clj} tool:

@example
$ clj
Downloading: clj-time/clj-time/0.14.2/clj-time-0.14.2.pom from https://clojars.org/repo/
Downloading: clj-time/clj-time/0.14.2/clj-time-0.14.2.jar from https://clojars.org/repo/
Clojure 1.9.0
user=> (require '[clj-time.core :as t])
nil
user=> (str (t/now))
"2017-12-06T19:36:56.159Z"
@end example

You will see messages about a library being downloaded the first time you use a
dependency.  Once the file is downloaded, it will be reused in the future.  You
can use  the same process to  add other libraries to  your @file{deps.edn} file
and explore Clojure or Java libraries.


@c .....................................

@node Write A Program With Deps
@subsection Write A Program Using A Dependency
@cindex deps
@cindex @file{deps.edn}
@cindex write program
@cindex program, write

@heading How To Create Hello World

Create a directory  @file{hello-world} and change to that  directory.  Copy the
@file{deps.edn} file into  this directory.  By default,  the @command{clj} tool
will  look  for  source  files  in the  @file{src}  directory,  so  create  the
@file{src} directory and declare your program at @file{src/hello.clj}:

@initial_setup
mkdir -p clj
@end initial_setup

@subheading @file{deps.edn} for Hello World

@(hello-world__deps.edn@)=
{:deps
  {clj-time {:mvn/version "0.4.2"}}}
@

@initial_setup
mkdir -p clj/hello-world
@end initial_setup

@post_create hello-world__deps.edn mv hello-world__deps.edn clj/hello-world/deps.edn

@subheading @file{src/hello.clj}

@initial_setup
mkdir -p clj/hello-world/src
mkdir -p clj/time-lib/src/
mkdir -p clj/hello-time/src
@end initial_setup

@(hello-world__hello.clj@)=
(ns hello
  (:require [clj-time.core :as t]
            [clj-time.format :as f]))

(defn time-str
  "Returns a string representation of a datetime in the local time zone."
  [dt]
  (f/unparse
    (f/with-zone (f/formatter "hh:mm aa") (t/default-time-zone))
    dt))

(defn -main []
  (println "Hello world, the time is" (time-str (t/now))))

@

@post_create hello-world__hello.clj mv hello-world__hello.clj clj/hello-world/src/hello.clj

@subheading Run Hello World

This program has  a static entry point named @code{-main}  that is suitable for
external invocation.  The @command{clj} tool acts as a Clojure program launcher
with the @option{-m} option, which specifies the namespace to run:

@example
$ clj -m hello
Hello world, the time is 02:04 PM
@end example

This  program can  be invoked  from the  command line  or via  a @command{make}
target @code{hello-world}.

@c _____________________________________

@node Makefile Target for Hello World
@appendixsubsubsec Makefile Target for Hello World

@<Makefile---Example Targets@>=
# HELLO WORLD
#############
.PHONY: hello-world

clj/hello-world/src/hello.clj : $(FILE).twjr
	jrtangle $(FILE).twjr

hello-world : clj/hello-world/src/hello.clj
	cd clj/hello-world && clj -m hello

@


@c .....................................

@node Using Local Libraries
@subsection Using Local Libraries
@cindex local libraries
@cindex local coordinates

You can move part  of this application into a library on  your local disk.  The
@command{clj} tool uses  local coordinates to support projects  that exist only
on your local disk.  Extract the  @file{clj-time} parts of this application out
into a library in a parallel directory @file{time-lib}.

@example
├── time-lib
│   ├── deps.edn
│   └── src
│       └── hello_time.clj
└── hello-time
    ├── deps.edn
    └── src
        └── hello.clj
@end example

@heading Library File @file{time-lib/src/hello_time.clj}

Under @file{time-lib}, use a copy of the @file{deps.edn} file you already have,
and create a file @file{src/hello_time.clj}:

@(time-lib__deps.edn@)=
{:deps
  {clj-time {:mvn/version "0.4.2"}}}

@

@post_create time-lib__deps.edn mv time-lib__deps.edn clj/time-lib/deps.edn

@(time-lib__hello_time.clj@)=
(ns hello-time
  (:require [clj-time.core :as t]
            [clj-time.format :as f]))

(defn now
  "Returns the current datetime"
  []
  (t/now))

(defn time-str
  "Returns a string representation of a datetime in the local time zone."
  [dt]
  (f/unparse
    (f/with-zone (f/formatter "hh:mm aa") (t/default-time-zone))
    dt))

@

@post_create time-lib__hello_time.clj mv time-lib__hello_time.clj clj/time-lib/src/hello_time.clj

@heading @file{hello-time__hello.clj}

Update the  application at @file{hello-world/src/hello.clj} to  use your library
instead (place the updated program in @file{hello-time/src}:

@(hello-time__hello.clj@)=
(ns hello
  (:require [hello-time :as ht]))

(defn -main []
  (println "Hello Time, the world is" (ht/time-str (ht/now))))

@

@post_create hello-time__hello.clj mv hello-time__hello.clj clj/hello-time/src/hello.clj

Modify @file{hello-world/deps.edn} to use a local coordinate that refers to the
root directory of the @file{time-lib} library (make sure to update the path for
your machine):

@(hello-time__deps.edn@)=
{:deps
 {time-lib {:local/root "../time-lib"}}}

@

@post_create hello-time__deps.edn mv hello-time__deps.edn clj/hello-time/deps.edn

You can  then test  everything from  the hello-world  directory by  running the
application:

@example
$ clj -m hello
Hello world, the time is 02:07 PM
@end example

@c _____________________________________

@node Makefile Hello Time Target
@appendixsubsubsec Makefile Hello Time Target

@<Makefile---Example Targets@>=
# HELLO TIME
############

.PHONY : hello-time

hello-time : clj/hello-time/src/hello.clj
	cd clj/hello-time && clj -m hello

clj/hello-time/src/hello.clj : $(FILE).twjr
	jrtangle $(FILE).twjr

@









@c *****************************************************************************

@node Resources
@chapter Resources
@cindex resources



@c -----------------------------------------------------------------------------

@node Community Resources
@section Community Resources
@cindex resources, community

@url{https://clojure.org/community/resources, Community Resources}


@c .....................................

@node Community Discussion
@subsection Community Discussion
@cindex resources, community discussion


@c .....................................

@node Community Tutorials
@subsection Community Tutorials
@cindex resources, tutorials
@cindex tutorials




@c -----------------------------------------------------------------------------

@node Learn Clojure
@section Learn Clojure
@cindex learn clojure

@url{https://clojure.org/guides/learn/syntax, Learn Clojure}




@c -----------------------------------------------------------------------------

@node Clojure From The Ground Up
@section Clojure From The Ground Up
@cindex from the ground up

@url{https://aphyr.com/posts/301-clojure-from-the-ground-up-welcome,
Clojure From The Ground Up}


@c .....................................

@node Welcome
@subsection Welcome To Clojure From The Ground Up
@cindex welcome

@heading Learn Functional Programming With Clojure

This book is about how to program.   This guide aims to introduce newcomers and
experienced programmers alike to the beauty of functional programming, starting
with the simplest  building blocks of software.  We’ll be  learning in Clojure,
which is a  modern dialect of a  very old family of  computer languages, called
Lisp.  @emph{By the end  of this series, you’ll have a  thorough command of the
Clojure programming language.}

@subheading What About Programming?

We’re going to explore the nature of syntax, metalanguages, values, references,
mutation,  control flow,  and concurrency.

@itemize
@item
syntax and its nature
@item
metalanguages
@item
values
@item
references
@item
mutation
@item
control flow
@item
concurrency
@end itemize

Many  languages leave  these ideas  implicit in  the language  construction, or
don’t have  a concept of  metalanguages or  concurrency at all.   Clojure makes
these ideas explicit, first-class language constructs.  At the same time, we’re
going  to  defer or  omit  any  serious  discussion  of static  type  analysis,
hardware, and performance.

@subheading What About Clojure?

In more  general terms, Clojure  is a  well-rounded language.  It  offers broad
library support and runs on multiple operating systems.  Clojure performance is
not  terrific,  but  is  orders  of magnitude  faster  than  Ruby,  Python,  or
Javascript.  Unlike  some faster  languages, Clojure  emphasizes safety  in its
type system  and approach  to parallelism,  making it  easier to  write correct
multithreaded  programs.  Clojure  is concise,  requiring very  little code  to
express complex  operations.  It offers a  REPL and dynamic type  system: ideal
for beginners to experiment with, and well-suited for manipulating complex data
structures.  A consistently designed standard  library and full-featured set of
core datatypes rounds out the Clojure toolbox.

@subheading Clojure's Drawbacks

Finally, there  are some drawbacks.   As a  compiled language, Clojure  is much
slower to start than a scripting language; this makes it unsuitable for writing
small  scripts  for interactive  use.   Clojure  is  also not  well-suited  for
high-performance numeric operations.   Though it is possible, you  have to jump
through hoops to achieve performance comparable  with Java.


@c .....................................

@node Some Preliminaries
@subsection Some Preliminaries

@table @b

@cindex @code{nil}
@item nil
@code{nil}  is  the most  basic  value  in  Clojure.  It  represents  emptiness,
nothing-doing, not-a-thing. The absence of information.

@cindex boolean
@cindex @code{true}
@cindex @code{false}
@cindex Lisp logical system
@item Booleans
@code{true}   and  @code{false}   are   a  pair   of   special  values   called
@dfn{Booleans}.  They mean exactly what you  think: whether a statement is true
or false.   @code{true}, @code{false}, and  @code{nil} form the three  poles of
the Lisp logical system.

@item Values
Values are the ``nouns'' of programming: @code{nil}, @code{true}, @code{0}, and
@code{"hi there!"} are all different types of values;

@cindex symbol
@item Symbols
But most  sentences aren’t just  about stating the  existence of a  thing; they
involve action.  We need verbs.

@verbatim
user=> inc
#<core$inc clojure.core$inc@6f7ef41c>
@end verbatim

This  is a  verb called  @code{inc} –  short for  ``increment''.  Specifically,
@code{inc}  is  a  @dfn{symbol}  which  points  to  a  verb:  @verb{|#<core$inc
clojure.core$inc@6f7ef41c>|}.   Symbols are  references to  other values.  When
Clojure evaluates a symbol, it looks up that symbol’s meaning.  Look up @code{inc}, and
you get @verb{|#<core$inc clojure.core$inc@6f7ef41c>|}.

@cindex quote
@item quote
Can we refer to the symbol itself, without looking up its meaning?

@verbatim
user=> 'inc
inc
@end verbatim

@cindex sentence
@cindex expression
@cindex statement
Yes. The single quote @kbd{'} escapes a sentence.  In programming languages, we
call  @dfn{sentences} @emph{expressions}  or @emph{statements}.   A quote  says
``Rather than evaluating this expression’s text, simply return the text itself,
unchanged.''  Quote  a symbol,  get a  symbol.  Quote a  number, get  a number.
Quote anything, and get it back exactly as it came in.

@item list
@cindex list
@cindex LISP

@verbatim
user=> '(1 2 3)
(1 2 3)
@end verbatim

A list  is new kind of  value, one surrounded by  parentheses.  LISP originally
stood for ``LISt Processing'', and lists are still at the core of the language.
In fact, they form the most basic  way to compose expressions, or sentences.  A
@dfn{list} is a single expression which has multiple parts.  For instance, this
list  contains three  elements: the  numbers  1, 2,  and 3.  Lists can  contain
anything: numbers, strings, even other lists.

@item sentence
But  let’s  try something  simpler.   Something  we  know  how to  talk  about.
``Increment the number zero.''  We have  a symbol for incrementing, and we know
how to write the number zero.  Let’s combine them in a list:

@verbatim
user=> '(inc 0)
(inc 0)
@end verbatim

@cindex sentence
@cindex expression
A basic  sentence.  Remember, since it’s  quoted, we’re talking about  the tree,
the text,  the expression, by itself.  Absent interpretation.  If we  remove the
single-quote, Clojure will interpret the expression:

@verbatim
user=> (inc 0)
1
@end verbatim

Incrementing zero yields one.  And if we wanted to increment that value?

@verbatim
user=> (inc (inc 0))
2
@end verbatim

@cindex sentence
A sentence in Lisp  is a list.  It starts with a verb,  and is followed by zero
or more objects for  that verb to act on.  Each part of  the list can itself be
another list, in  which case that nested  list is evaluated first,  just like a
nested clause in a  sentence.  Every list starts with a verb.   Parts of a list
are evaluated from  left to right.  Innermost lists are  evaluated before outer
lists.

@verbatim
(+ 1 (- 5 2) (+ 3 4))
(+ 1 3       (+ 3 4))
(+ 1 3       7)
11
@end verbatim

@cindex grammar
@item grammar
That’s it.  The  entire grammar of Lisp: the structure  for every expression in
the language.  We transform expressions  by substituting meanings  for symbols,
and obtain some result.

@cindex lambda calculus
@item Lambda Calculus
This is the  core of the Lambda  Calculus, and it is the  theoretical basis for
almost  all  computer languages.   All  languages  express  the text  of  their
programs  in   different  ways,  but   internally  all  construct  a   tree  of
expressions.  Lisp simply makes it explicit.

@end table


@c .....................................

@node Types
@subsection Types
@cindex type

We say that a @dfn{type} is a group of values which work in the same way.  It’s
a property that some  values share, which allows us to  organize the world into
sets of similar things.  Types also help  us verify that a program makes sense.
Types can overlap and intersect each other.  Other types completely subsume one
another.

Every language  has a type  system; a particular  way of organizing  nouns into
types, figuring out  which verbs make sense on which  types, and relating types
to  one another.  Some  languages are  strict, and  others  more relaxed.  Some
emphasize hierarchy, and others a more ad-hoc view of the world.

@heading Clojure's Type System Is Strong And Dynamic
@cindex strong type system
@cindex dynamic type system

We  call Clojure’s  type system  @emph{strong} in  that operations  on improper
types are simply not  allowed: the program will explode if  asked to subtract a
dandelion.  We  also say that  Clojure’s types are @emph{dynamic}  because they
are enforced when the program is run, instead of when the program is first read
by the computer.

Because Clojure is built  on top of Java, many of its types  are plain old Java
types.

@c _____________________________________

@node Integers
@subsubsection Integers
@cindex integer type
@cindex @file{java.lang.Long}
@cindex Long

@heading Long

Clojure's basic Integer type is a @file{java.lang.Long}, or ``Long'' for short.

@example
user=> (type 3)
java.lang.Long
@end example

@cindex signed two's complement representation
Longs, internally, are represented as a group of sixty-four binary digits (ones
and zeroes),  written down  in a particular  pattern called  @emph{signed two’s
complement representation}.

There are only two things to remember about Longs:

@enumerate
@item
Longs  use one  bit  to store  the  sign:  whether the  number  is positive  or
negative.

@item
@cindex MAX_VALUE
The other 63 bits represent the size of the number.  The biggest number you can
represent with a long  is: 2^^63 - 1 (called MAX_VALUE),  and the smallest long
is -2^^63.

@verbatim
user=> Long/MAX_VALUE
9223372036854775807
@end verbatim

@end enumerate

@heading Type Protection

What happens if you add one to the biggest Long?

@example
user=> (inc Long/MAX_VALUE)

ArithmeticException integer overflow
clojure.lang.Numbers.throwIntOverflow
(Numbers.java:1388)
@end example

@cindex integer overflow error
An error  occurs!  This is Clojure  telling us that something  went wrong.  The
type of error was an  @file{ArithmeticException}, and its message was ``integer
overflow'', meaning ``this type of number  can’t hold a number that big''.  The
error  came  from  a  specific  place  in  the  source  code  of  the  program:
@file{Numbers.java}, on line 1388.  That’s a part of the Clojure source code.

The  important thing  is that  Clojure’s type  system protected  us from  doing
something  dangerous;  instead  of  returning   a  corrupt  value,  it  aborted
evaluation and returned an error.

@heading BigInt
@cindex BigInt
@cindex @code{bigint}
@cindex arbitrary-precision integers

If you  do need  to talk about  really big  numbers, you can  use a  BigInt: an
arbitrary-precision integer.  Let’s convert the biggest Long into a BigInt, then
increment it:

@example
user=> (inc (bigint Long/MAX_VALUE))
9223372036854775808N
@end example

Notice  the  N at  the  end?   That’s  how Clojure  writes  arbitrary-precision
integers.

@example
user=> (type 5N)
clojure.lang.BigInt
@end example

@heading Integer, Short, And Byte

There are also smaller integers.

@example
user=> (type (int 0))
java.lang.Integer
user=> (type (short 0))
java.lang.Short
user=> (type (byte 0))
java.lang.Byte
@end example

@subheading Integer
@cindex Integer

Integers are half the size of Longs; they store values in 32 bits.
Their largest value is therefore 2^^31 - 1.

@subheading Short
@cindex Short

Shorts are 16 bits.  Largest value is 2^^15 - 1.

@subheading Byte
@cindex Byte

Bytes are 8 bits.  Largest value is 2^^7 - 1.

@subheading Largest Integer Values

@example
user=> Integer/MAX_VALUE
2147483647
user=> Short/MAX_VALUE
32767
user=> Byte/MAX_VALUE
127
@end example

@c _____________________________________

@node Fractional Numbers
@subsubsection Fractional Numbers
@cindex fractional numbers
@cindex floating-point numbers
@cindex Double
@cindex Float

@heading Floating-Point Numbers

To represent  numbers between  integers, we  often use  floating-point numbers,
which can represent  small numbers with fine precision, and  large numbers with
coarse  precision.  The  important  thing to  know is  floats  and doubles  are
approximations. There are limits to their correctness.

@enumerate
@item
Floats use 32  bits

@item
Doubles  use 64.  Doubles  are the default in Clojure.

@item
To represent fractions exactly, we can use the ratio type:

@verbatim
user=> (type 1/3)
clojure.lang.Ratio
@end verbatim
@end enumerate

@example
user=> (type 1.23)
java.lang.Double
user=> (type (float 1.23))
java.lang.Float

user=> 0.99999999999999999
1.0
@end example


@c _____________________________________

@node Mathematical Operators
@subsubsection Mathematical Operators
@cindex mathemtical operators
@cindex operators

The  exact behavior  of mathematical  operations  in Clojure  depends on  their
types.  In general,  though, Clojure aims to preserve  information.  Adding two
longs returns a long; adding a double and a long returns a double.

@example
user=> (+ 1 2)
3
user=> (+ 1 2.0)
3.0
@end example

3 and 3.0 are not the same number; one  is a long, and the other a double.  But
for most purposes, they’re equivalent, and Clojure will tell you so:

@example
user=> (= 3 3.0)
false
user=> (== 3 3.0)
true
@end example

@cindex @kbd{=}
@cindex @kbd{==}
@cindex equivalence
@kbd{=} asks  whether all the things  that follow are equal.   Since floats are
approximations, @kbd{=} considers them  different from integers.  @kbd{==} also
compares things, but a little more loosely: it considers integers equivalent to
their floating-point representations.

@cindex add
@cindex subtract
@cindex multiply
@cindex divide
We  can also  subtract with  @kbd{-}, multiply  with @kbd{*},  and divide  with
@kbd{/}.

@cindex n-arity
Putting the verb first in each list allows  us to add or multiply more than one
number in the same step:

@example
user=> (+ 1 2 3)
6
user=> (* 2 3 1/5)
6/5
@end example

Subtraction  with more  than 2  numbers subtracts  all later  numbers from  the
first.  Division divides the first number by all the rest.

@example
user=> (- 5 1 1 1)
2
user=> (/ 24 2 3)
4
@end example

@cindex single-arity
By extension, we can define  useful interpretations for numeric operations with
just a single number:

@example
user=> (+ 2)
2
user=> (- 2)
-2
user=> (* 4)
4
user=> (/ 4)
1/4
@end example

@cindex identify
@cindex additive identiy
@cindex multiplicative identity
We can also add or multiply a list of no numbers at all, obtaining the additive
and multiplicative  identities, respectively.  This might seem  odd, especially
coming from  other languages,  but we’ll see  later that  these generalizations
make it easier to reason about higher-level numeric operations.

@example
user=> (+)
0
user=> (*)
1
@end example

@cindex @kbd{<=}
@cindex @kbd{>=}
Often, we want  to ask which number  is bigger, or if one  number falls between
two others.  @kbd{<=} means  ``less than  or equal to'',  and asserts  that all
following values are in order from smallest to biggest.

@example
user=> (<= 1 2 3)
true
user=> (<= 1 3 2)
false
@end example

@cindex @kbd{<}
@cindex @kbd{>}
@kbd{<} means ``strictly less than'', and works just like <@kbd{=}, except that
no two values may be equal.

@example
user=> (<= 1 1 2)
true
user=> (< 1 1 2)
false
@end example

Their friends @kbd{>} and @kbd{>=} mean  ``greater than'' and ``greater than or
equal to'', respectively, and assert that numbers are in descending order.

@example
user=> (> 3 2 1)
true
user=> (> 1 2 3)
false
@end example

@cindex @code{inc}
@cindex @code{dec}
Also commonly used are @code{inc} and @code{dec}, which add and subtract one to
a number, respectively.

One final note: equality tests can take more than 2 numbers as well.

@example
user=> (= 2 2 2)
true
user=> (= 2 2 3)
false
@end example


@c _____________________________________

@node Strings
@subsubsection Strings
@cindex strings

We saw that strings are text, surrounded by double quotes, like "foo".  Strings
in Clojure are, like Longs, Doubles, and company, backed by a Java type:

@example
user=> (type "cat")
java.lang.String
@end example

@subheading @code{str}

We can make  almost anything into a string with  @code{str}.  Strings, symbols,
numbers, booleans;  every value in  Clojure has a string  representation.  Note
that @code{nil}’s string representation is ""; an empty string.

@example
user=> (str "cat")
"cat"
user=> (str 'cat)
"cat"
user=> (str 1)
"1"
user=> (str true)
"true"
user=> (str '(1 2 3))
"(1 2 3)"
user=> (str nil)
""
@end example

@subsubheading @code{str} Concatenation

@code{str} can also combine things together into a single string, which we call
@dfn{concatenation}.

@example
user=> (str "meow " 3 " times")
"meow 3 times"
@end example

@heading Regular Expressions
@cindex regular expression
@cindex @code{re-find}
@cindex @code{re-matches}

To look for patterns in text, we can use a @dfn{regular expression}, which is a
tiny language  for describing particular arrangements  of text.  @code{re-find}
and @code{re-matches} look for occurrences of a regular expression in a string.
To find a cat:

@example
user=> (re-find #"cat" "mystic cat mouse")
"cat"
user=> (re-find #"cat" "only dogs here")
nil
@end example

That @samp{#"..."} is Clojure’s way of writing a regular expression.

With  @code{re-matches}, you  can extract  particular parts  of a  string which
match an  expression.  Here we find  two strings, separated by  a @kbd{:}.  The
parentheses mean  that the regular expression  should capture that part  of the
match.  We get back  a list containing the part of the  string that matched the
first parentheses, followed by the part that matched the second parentheses.

@example
user=> (rest (re-matches #"(.+):(.+)" "mouse:treat"))
("mouse" "treat")
@end example

Regular  expressions are  a  powerful  tool for  searching  and matching  text,
especially when working  with data files.  Since regexes work  the same in most
languages, you can use any guide online  to learn more.  It’s not something you
have to  master right  away; just learn  specific tricks as  you find  you need
them.   For   a  deeper  guide,  try   Fitzgerald’s  @cite{Introducing  Regular
Expressions}.

@c_____________________________________

@node Booleans
@subsubsection Booleans and Logic
@cindex boolean type
@cindex logic
@cindex truthiness
@cindex @code{true}
@cindex @code{false}
@cindex @code{nil}

@heading Truthiness

Everything in  Clojure has a  sort of charge,  a truth value,  sometimes called
``truthiness''.   @code{true}   is  positive  and  @code{false}   is  negative.
@code{nil} is negative, too.

@subheading @code{false} Values
@cindex @code{false}

@example
user=> (boolean false)
false
user=> (boolean nil)
false
@end example

@subheading @code{true} Values
@cindex @code{true}

Every other value in Clojure is positive.

@example
user=> (boolean true)
true
user=> (boolean 0)
true
user=> (boolean 1)
true
user=> (boolean "hi there")
true
user=> (boolean str)
true
@end example

If you’re coming from a C-inspired  language, where 0 is considered false, this
might be a bit surprising.  Likewise, in much of POSIX, 0 is considered success
and  nonzero values  are failures.   Lisp allows  no such  confusion: the  only
negative values are @code{false} and @code{nil}.

@heading @code{and or not}

We can reason  about truth values using @code{and},  @code{or}, and @code{not}.
@code{and}  returns the  first negative  value, or  the last  value if  all are
truthy.

@subheading @code{and}
@cindex @code{and}

@example
user=> (and true false true)
false
user=> (and true true true)
true
user=> (and 1 2 3)
3
@end example

@subheading @code{or}
@cindex @code{or}

Similarly, or returns the first positive value.

@example
user=> (or false 2 3)
2
user=> (or false nil)
nil
@end example

@subheading @code{not}
@cindex @code{not}

And @code{not} inverts the logical sense of a value:

@example
user=> (not 2)
false
user=> (not nil)
true
@end example

@subheading Boolean Logic
@cindex boolean logic

We’ll learn more about Boolean logic  when we start talking about control flow;
the way we alter evaluation of a program  and express ideas like ``if I’m a cat,
then meow incessantly''.

@c _____________________________________

@node Symbols
@subsubsection Symbols
@cindex symbols

Symbols are bare strings of characters, like @samp{foo} or @kbd{+}.

@example
user=> (class 'str)
clojure.lang.Symbol
@end example

@cindex symbol, names
Symbols can have either  short or full names.  The short name  is used to refer
to things locally.  The fully qualified  name is used to refer unambiguously to
a symbol from anywhere.  If I were a  symbol, my name would be ``Kyle'', and my
full name ``Kyle Kingsbury.''

Symbol names are separated with a @kbd{/}.  For instance, the symbol @code{str}
is also present in a  family called @file{clojure.core}; the corresponding full
name is @code{clojure.core/str}.

@example
user=> (= str clojure.core/str)
true
user=> (name 'clojure.core/str)
"str"
@end example

When we talked about the maximum size of an integer, that was a fully-qualified
symbol, too.

@example
(type 'Integer/MAX_VALUE)
clojure.lang.Symbol
@end example

The job  of symbols  is to  refer to things,  to point  to other  values.  When
evaluating a program, symbols are looked up and replaced by their corresponding
values.  That’s not the only use of symbols, but it’s the most common.

@c _____________________________________

@node Keywords
@subsubsection Keywords
@cindex Keywords

Closely  related to  symbols  and  strings are  keywords,  which  begin with  a
@kbd{:}.  Keywords are  like strings in that  they’re made up of  text, but are
specifically intended for use as labels or identifiers.  These aren’t labels in
the sense  of symbols: keywords  aren’t replaced  by any other  value.  They’re
just names, by themselves.

@example
user=> (type :cat)
clojure.lang.Keyword
user=> (str :cat)
":cat"
user=> (name :cat)
"cat"
@end example

As  labels,  keywords are  most  useful  when paired  with  other  values in  a
collection, like a map.  Keywords can also be used as verbs to look up specific
values in other data types.  We’ll learn more about keywords shortly.

@c _____________________________________

@node Lists
@subsubsection Lists
@cindex lists

A  collection is  a group  of  values.  It’s  a container  which provides  some
structure,  some framework,  for  the things  that  it holds.   We  say that  a
collection contains elements, or members.  We  saw one kind of collection --- a
list --- in the previous chapter.

@example
user=> '(1 2 3)
(1 2 3)
user=> (type '(1 2 3))
clojure.lang.PersistentList
@end example

@cindex @code{quote}
@cindex @code{list}
Remember,  we  quote   lists  with  a  @kbd{'}  to  prevent   them  from  being
evaluated.  You can also construct a list using @code{list}:

@example
user=> (list 1 2 3)
(1 2 3)
@end example

Lists are comparable just like every other value:

@example
user=> (= (list 1 2) (list 1 2))
true
@end example

@cindex @code{conj}
You can modify a list by @code{conj}oining an element onto it:

@example
user=> (conj '(1 2 3) 4)
(4 1 2 3)
@end example

@cindex linked list
We added  4 to the  list ---  but it appeared  at the front.   Why? Internally,
lists are  stored as a chain  of values: each link  in the chain is  a tiny box
which holds the value and a connection  to the next link.  This data structure,
called a @dfn{linked list}, offers immediate  access to the first element.  But
getting to  the second element  requires an extra hop  down the chain;  and the
third element a hop after that, and so on.

@cindex @code{first}
@cindex @code{second}
@example
user=> (first (list 1 2 3))
1

user=> (second (list 1 2 3))
2

user=> (nth (list 1 2 3) 2)
3
@end example

@cindex @code{nth}
@code{nth} gets the element of an ordered collection at a particular index.  The
first element is index 0, the second is index 1, and so on.

This means  that lists  are well-suited for  small collections,  or collections
which are  read in linear order,  but are slow  when you want to  get arbitrary
elements from  later in the list.  For fast access  to every element, we  use a
vector.

@c _____________________________________

@node Vectors
@subsubsection Vectors
@cindex vector

Vectors are  surrounded by square brackets,  just like lists are  surrounded by
parentheses.  Because vectors  aren’t evaluated like lists are,  there’s no need
to quote them:

@example
user=> [1 2 3]
[1 2 3]
user=> (type [1 2 3])
clojure.lang.PersistentVector
@end example

@cindex @code{vector}
@cindex @code{vec}
You can also create vectors with @code{vector}, or change other structures into
vectors with @code{vec}:

@example
user=> (vector 1 2 3)
[1 2 3]
user=> (vec (list 1 2 3))
[1 2 3]
@end example

@cindex @code{conj}
@code{conj} on a vector adds to the end, not the start:

@example
user=> (conj [1 2 3] 4)
[1 2 3 4]
@end example

@cindex @code{first}
@cindex @code{second}
@cindex @code{nth}
Our  friends @code{first},  @code{second}, and  @code{nth} work  here too;  but
unlike  lists,  @code{nth} is  fast  on  vectors.  That’s  because  internally,
vectors are represented  as a very broad  tree of elements, where  each part of
the tree branches  into 32 smaller trees.   Even very large vectors  are only a
few layers deep, which means getting to elements only takes a few hops.

In addition  to first,  you’ll often want  to get the  remaining elements  in a
collection.  There are two ways to do this:

@cindex @code{rest}
@cindex @code{next}
@example
user=> (rest [1 2 3])
(2 3)
user=> (next [1 2 3])
(2 3)
@end example

@code{rest} and @code{next}  both return ``everything but  the first element''.
They differ only by what happens when there are no remaining elements:

@example
user=> (rest [1])
()
user=> (next [1])
nil
@end example

@code{rest}  returns logical  @code{true}, @code{next}  returns logical  false.
Each  has  their uses,  but  in  almost every  case  they’re  equivalent ---  I
interchange them freely.

@cindex @code{last}
We can get the final element of any collection with @code{last}:

@example
user=> (last [1 2 3])
3
@end example

@cindex @code{count}
And figure out how big the vector is with @code{count}:

@example
user=> (count [1 2 3])
3
@end example

Because vectors are intended for looking up  elements by index, we can also use
them directly as verbs:

@example
user=> ([:a :b :c] 1)
:b
@end example

So we took the vector containing  three keywords, and asked ``What’s the element
at index 1?''  Lisp, like most (but  not all!) modern languages,  counts up from
zero, not one.  Index 0 is the first element, index 1 is the second element, and
so on.  In this vector, finding the element at index 1 evaluates to :b.

Finally,  note  that  vectors  and  lists  containing  the  same  elements  are
considered equal in Clojure:

@example
user=> (= '(1 2 3) [1 2 3])
true
@end example

In almost all contexts, you can consider vectors, lists, and other sequences as
interchangeable.  They only differ in their performance characteristics, and in
a few data-structure-specific operations.

@c _____________________________________

@node Sets
@subsubsection Sets
@cindex set

Sometimes you want an unordered collection  of values; especially when you plan
to  ask  questions like  ``does  the  collection have  the  number  3 in  it?''
Clojure, like most languages, calls these collections @dfn{sets}.

@example
user=> #@{:a :b :c@}
#@{:a :c :b@}
@end example

Sets are  surrounded by  @samp{#@{@dots{}@}}.  Notice that  though we  gave the
elements :a, :b, and  :c, they came out in a different  order.  In general, the
order of sets can  shift at any time.  If you want a  particular order, you can
ask for it as a list or vector:

@example
user=> (vec #@{:a :b :c@})
[:a :c :b]
@end example

Or ask for the elements in sorted order:

@example
(sort #@{:a :b :c@})
(:a :b :c)
@end example

@cindex @code{conj}
@code{conj} on a set adds an element:

@example
user=> (conj #@{:a :b :c@} :d)
#@{:a :c :b :d@}
user=> (conj #@{:a :b :c@} :a)
#@{:a :c :b@}
@end example

@cindex @code{disj}
Sets never  contain an  element more  than once,  so @code{conj}ing  an element
which is  already present does  nothing.  Conversely, one removes  elements with
@code{disj}:

@example
user=> (disj #@{"hornet" "hummingbird"@} "hummingbird")
#@{"hornet"@}
@end example

@cindex @code{contains?}
The most common  operation with a set  is to check whether  something is inside
it.  For this we use @code{contains?}.

@example
user=> (contains? #@{1 2 3@} 3)
true
user=> (contains? #@{1 2 3@} 5)
false
@end example

Like vectors,  you can  use the set  itself as a  verb.  Unlike  @code{contains?}, this
expression returns the element itself (if it was present), or nil.

@example
user=> (#@{1 2 3@} 3)
3
user=> (#@{1 2 3@} 4)
nil
@end example

You can make a set out of any other collection with @code{set}.

@example
user=> (set [:a :b :c])
#@{:a :c :b@}
@end example

@c _____________________________________

@node Maps
@subsubsection Maps
@cindex map

The  last collection  on our  tour  is the  @dfn{map}: a  data structure  which
associates  keys with  values.  In  a  dictionary, the  keys are  words and  the
definitions are the  values.  In a library,  keys are call signs,  and the books
are  values.  Maps  are  indexes for  looking things  up,  and for  representing
different pieces of named information together.  Here’s a cat:

@example
user=> @{:name "mittens" :weight 9 :color "black"@}
@{:weight 9, :name "mittens", :color "black"@}
@end example

Maps are  surrounded by braces  @samp{@{@dots{}@}}, filled by  alternating keys
and values.  In  this map, the three  keys are :name, :color,  and :weight, and
their values are  "mittens", "black", and 9, respectively.  We  can look up the
corresponding value for a key with @code{get}:

@example
user=> (get @{"cat" "meow" "dog" "woof"@} "cat")
"meow"
user=> (get @{:a 1 :b 2@} :c)
nil
@end example

@cindex @code{get}
@code{get} can  also take a default  value to return instead  of @code{nil}, if
the key doesn’t exist in that map.

@example
user=> (get @{:glinda :good@} :wicked :not-here)
:not-here
@end example

Since lookups are so important for maps, we can use a map as a verb directly:

@example
user=> (@{"amlodipine" 12 "ibuprofen" 50@} "ibuprofen")
50
@end example

And conversely, keywords can also be used as verbs, which look themselves up in
maps:

@example
user=> (:raccoon @{:weasel "queen" :raccoon "king"@})
"king"
@end example

@cindex @code{assoc}
You can add a value for a given key to a map with @code{assoc}.

@example
user=> (assoc @{:bolts 1088@} :camshafts 3)
@{:camshafts 3 :bolts 1088@}
user=> (assoc @{:camshafts 3@} :camshafts 2)
@{:camshafts 2@}
@end example

@code{assoc} adds keys  if they aren’t present, and replaces  values if they’re
already there.  If you associate a value onto @code{nil}, it creates a new map.






@c *****************************************************************************

@node Clojure API Documentation
@chapter Clojure API Documentation
@cindex api

@url{https://clojure.org/api/api, Clojure API Documentation}

@heading Cheatsheet

@url{https://clojure.org/api/cheatsheet, Cheatsheet}

@heading ClojureDocs

@url{https://clojuredocs.org/, ClojureDocs}








@c ============================================================================
@c APPENDICES
@c =============================================================================








@c *****************************************************************************

@node First appendix
@appendix First Appendix Title

Some appendix here.






@c *****************************************************************************

@node The Makefile
@appendix The Makefile
@cindex makefile


@(Makefile@)=
# MAKEFILE FILE CHUNKS
######################

@<Makefile---Variable Definitions@>
@<Makefile---Default Target@>
@<Makefile---TWJR Targets@>
@<Makefile---Clean Targets@>
@<Makefile---Example Targets@>

@




@c -----------------------------------------------------------------------------

@node Makefile Variable Definitions
@appendixsec Makefile Variable Definitions

@<Makefile---Variable Definitions@>=
# VARIABLE DEFINITIONS
######################

FILE  := Clojure-Lang
SHELL := /bin/bash

@




@c -----------------------------------------------------------------------------

@node Makefile Default Target
@appendixsec Default Target
@cindex default target

The @code{default} target processes the  @code{TEXI} source file into an
@code{INFO} file,  a @code{PDF} document,  and an @code{HTML}  web site.
This process  depepnds upon the  @code{TEXI} file having  been generated
from the @code{TWJR} file and its menus and nodes updated first.

The  target  @code{TWJR}  will   run  both  commands  @command{jrtangle}
(producing code  output) and @command{jrweave}  (producing documentation
source code  output) on the  @code{TWJRJ} source code, while  the target
@code{WEAVE} (or  alternatively @code{TEXI})  will run just  the command
@command{jrweave} on the @file{TWJR} file.

In either  case, the  documentation source  code (the  @file{TEXI} file)
will need  to be  updated, which  involves updating  its menus  and node
links.   You  may then  run  the  @code{default} target,  producing  the
@acronym{INFO}, @acronym{PDF}, and @acronym{HTML} files.

@<Makefile---Default Target@>=
# DEFAULT Target
################
.PHONY : TWJR TANGLE WEAVE TEXI INFO PDF HTML
.PHONY : default twjr tangle jrtangle weave texi info pdf html
default : INFO PDF HTML

@




@c -----------------------------------------------------------------------------


@node Makefile TWJR Targets
@appendixsec TWJR Targets
@cindex TWJR targets

These targets are all related to processing the main source @acronym{TWJR} file
in  some  way.   The  target  @code{twjr} ``tangles  and  weaves''  the  source
document.     @code{info}    runs     @command{makeinfo},    @code{pdf}    runs
@command{pdftexi2dvi}, and @code{html} runs @command{makeinfo --html}.

@<Makefile---TWJR Targets@>=
# TWJR TARGETS
##############
TWJR : twjr
twjr : distclean tangle weave

TANGLE : tangle
tangle : jrtangle
jrtangle : 
	jrtangle $(FILE).twjr

WEAVE : weave
weave : TEXI
TEXI  : texi
texi  : $(FILE).texi
$(FILE).texi : $(FILE).twjr
	jrweave $(FILE).twjr > $(FILE).texi

INFO : info
info : $(FILE).info
$(FILE).info : $(FILE).texi
	makeinfo $(FILE).texi
openinfo : INFO
	emacs $(FILE).info

PDF : pdf
pdf : $(FILE).pdf
$(FILE).pdf : $(FILE).texi
	pdftexi2dvi --build=tidy --build-dir=build --quiet $(FILE).texi
openpdf : PDF
	open $(FILE).pdf

HTML : html
html : $(FILE)/index.html
$(FILE)/index.html : $(FILE).texi
	makeinfo --html $(FILE).texi
openhtml : HTML
	open $(FILE)/index.html

@




@c -----------------------------------------------------------------------------

@node Makefile Clean Targets
@appendixsec Makefile Clean Targets
@cindex Makefile clean targets

The @command{clean} target removes backup files.  The @command{dirclean} target
removes  source  directories,  (e.g.,  @file{bin/}  and  and  @file{src/})  and
associated  files and  programs  inside them.   The @command{distclean}  target
removes  the  @file{HTML} directory  and  all  of its  files,  as  well as  the
@file{PDF}  file.    Finally,  the  @command{worldclean}  target   removes  the
@file{INFO} files, leaving the three files:

@itemize
@item
@file{TWJR}
@item
@file{TEXI}
@item
@file{MAKEFILE}
@end itemize

The @file{TEXI} file is always left because  it will be accurate so long as the
@file{TWJR} file is not modified, and  if the @file{TWJR} is modified, then the
@file{TEXI} file will be resourced automatically.

@<Makefile---Clean Targets@>=
.PHONY : clean dirclean distclean worldclean

# remove backup files
clean :
	rm -f *~ .*~ #*#

# remove all directories; leave TexiwebJr, Texinfo files, Makefile
dirclean : clean
	for file in *; do          \
	  case $$file in           \
	    $(FILE)* | Makefile) ;;\
	    my-bib-macros*)      ;;\
	    *) rm -vfr $$file	 ;;\
	  esac                     \
	done

# after dirclean, remove HTML and PDF files
distclean : dirclean
	rm -vfr $(FILE) $(FILE).pdf

# after distclean, remove INFO
worldclean : distclean
	rm -rfv $(FILE).info*

@




@c -----------------------------------------------------------------------------

@node Makefile Example Targets
@appendixsec Makefile Example Targets
@cindex makefile example targets

@<Makefile---Example Targets@>=

@








@c *****************************************************************************
@node Code Chunk Summaries
@appendix Code Chunk Summaries

This @value{APPENDIX} presents alphabetical lists of
all the file definitions, the code chunk definitions,
and the code chunk references.

@menu
* File Definitions::          Source files by definition.
* Code Chunk Definitions::    Code chunks by definition.
* Code Chunk References::     Code chunks by reference.
@end menu




@c -----------------------------------------------------------------------------
@node File Definitions
@appendixsec Source File Definitions

@print_file_defs




@c -----------------------------------------------------------------------------
@node Code Chunk Definitions
@appendixsec Code Chunk Definitions

@print_code_defs




@c -----------------------------------------------------------------------------
@node Code Chunk References
@appendixsec Code Chunk References

@print_code_refs







@c *****************************************************************************
@node Bibliography
@unnumbered Bibliography








@c *****************************************************************************

@node List of Tables
@unnumbered List of Tables

@listoffloats Table








@c  *****************************************************************************
@node Concept Index
@unnumbered Index

@printindex cp

@bye

TODO:
