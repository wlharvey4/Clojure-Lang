\input texinfo   @c -*- mode: texinfo -*-

@c FILE    Clojure-Lang.twjr
@c VERSION 0.1.0
@c DATE    2018-11-08T23:45
@c AUTHOR  wlharvey4

@c *****************************************************************************
@c %**start of header

@setfilename  Clojure-Lang.info
@settitle     Clojure Language Reference

@c %**end of header
@c *****************************************************************************

@c -----------------------------------------------------------------------------
@set TITLE      Clojure Language Reference
@set SHORTTITLE Clojure Lang
@set AUTHOR WLHarvey4
@set EDITION 0.1
@set UPDATE-MONTH NOVEMBER, 2018 @c goes in the subtitle
@set COPYRIGHT-YEAR 2018
@set COPYRIGHT-HOLDER WLHarvey4
@set ADDRESS1 Address Line 1
@set ADDRESS2 Address Line 2
@c -----------------------------------------------------------------------------








@c *****************************************************************************
@c BIBCITE MACROS
@c *****************************************************************************

@c need to load macros before header
@macro mybibsetrefnode{node}
@set mybibrefnode \node\
@end macro

@macro mybibnode{}
@value{mybibrefnode}
@end macro

@macro mybibusetable{node}
@set mybibtable true
@ifset mybiblist
@clear mybiblist
@end ifset
@mybibsetrefnode{\node\}
@end macro

@macro mybibuselist{node}
@set mybiblist true
@ifset mybibtable
@clear mybibtable
@end ifset
@mybibsetrefnode{\node\}
@end macro

@macro mybibcite{ref}
@inlineifclear{mybibrefnode, @mybibmakeref{mybibsetrefnode was not used, \ref\}}
@ifset mybibrefnode
@mybibmakeref{@mybibnode{}, \ref\}
@end ifset

@end macro

@macro mybibmakeref{node, ref}
(See item @cite{\ref\} in @ref{\ref\,,\node\}.)
@end macro

@macro mybibitem{ref}
@ifclear mybiblist
@ifclear mybibtable
@set mybiblist true
@end ifclear
@end ifclear

@ifset mybiblist
@item
@anchor{\ref\}[\ref\]
@end ifset

@ifset mybibtable
@item @anchor{\ref\}\ref\ ---
@end ifset

@end macro

@mybibusetable{Bibliography}

@c /////////////////////////////////////////////////////////////////////////////








@c *****************************************************************************
@c FINALOUT / DRAFT / FORPRINT
@c *****************************************************************************

@set      DRAFT @i{DRAFT} @c when set, print DRAFT in heading
@c @clear DRAFT  @c when clear, don't print DRAFT in heading
@clear  FINALOUT @c when clear, show black boxes for overfull lines
@c @set FINALOUT @c when set, don't show black boxes for overfull lines
@clear  FORPRINT @c when clear, PDF output is for viewing, not printing
@c @set FORPRINT @c when set, PDF output is for printing, not viewing

@c -----------------------------------------------------------------------------
@iftex
@ifset FINALOUT @c don't show black boxes for final printout
@finalout
@end ifset
@end iftex

@c Uncomment this for the release.  Leaving it off saves paper
@c during editing and review.
@ifset FORPRINT
@ifset FINALOUT
@c @setchapternewpage odd
@end ifset
@end ifset

@ifclear FORPRINT
@pdflinkcolor
@urllinkcolor
@hideurls
@end ifclear

@c -----------------------------------------------------------------------------








@c *****************************************************************************
@c SECTIONING
@c *****************************************************************************

@iftex
@set DOCUMENT book
@set CHAPTER chapter
@set APPENDIX appendix
@set SECTION section
@set SUBSECTION subsection
@end iftex
@ifhtml
@set DOCUMENT Web page
@set CHAPTER chapter
@set APPENDIX appendix
@set SECTION section
@set SUBSECTION subsection
@end ifhtml
@ifinfo
@set DOCUMENT Info file
@set CHAPTER major node
@set APPENDIX major node
@set SECTION minor node
@set SUBSECTION node
@end ifinfo
@ifdocbook
@set DOCUMENT book
@set CHAPTER chapter
@set APPENDIX appendix
@set SECTION section
@set SUBSECTION subsection
@end ifdocbook



@c merge the function and variable indexes into the concept index
@c do so without the code font, and in the index entries do the
@c font management ourselves.  Also merge in the chunk definition
@c and reference entries, which jrweave creates for us.
@ifnothtml
@synindex fn cp
@synindex vr cp
@synindex cd cp
@synindex cr cp
@end ifnothtml

@c /////////////////////////////////////////////////////////////////////////////








@c *****************************************************************************
@c SPECIAL TEXIWEBJR COMMANDS
@c *****************************************************************************

@c Change how xref titles are quoted.
@dquotexrefs
@c And let braces in index entries work.
@allowindexbraces

@c some special symbols
@ifnottex
@macro ii{text}
@i{\text\}
@end macro
@end ifnottex




@c <------------------------------------->
@c The initial_setup code runs as a script
@c in a  BEGIN section  of AWK  during the
@c tangling  phase  before any  files  are
@c extracted.   Here  create  a  directory
@c structure for  project files,  plus any
@c other initialization that might need to
@c be   done.    Files  are   moved   into
@c directories in a @post_create command.

@initial_setup
printf "${YELLOW}In initial_setup...${BLUEBOLD}\n"

ROOT="$PWD"
FILES="files"
SUBDIRS="src doc tst bin"

for file in ${SUBDIRS}
do
    ! [ -d $file ] && mkdir -vp ${ROOT}/${FILES}/${file}
done

printf "${GREEN}initial setup done.${CLEAR}\n"

@end initial_setup
@c <------------------------------------->


@c END Special TexiwebJr Commands
@c /////////////////////////////////////////////////////////////////////////////








@c %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@c BEGIN PRINTED MATTER
@c --COPYING
@c --FRONT MATTER
@c   **TITLE PAGES
@c     ..Short Title
@c     ..Title Page
@c     ..Copyright Page
@c --MAIN MATTER
@c   **Top
@c     --- unpaginated ---
@c     ..General Introduction
@c     ..Menus
@c     ..Table of Contents
@c     --- paginated --- unnumbered ---
@c     ..Front Matter
@c       ~~Forward
@c       ~~Preface
@c     --- paginated --- numbered ---
@c     ..Main Matter
@c       ~~Chapters
@c         >>Sections
@c           ^^Subsections
@c             ##Subsubsections
@c     --- paginated --- lettered ---
@c       ~~Appendices
@c --BACK MATTER
@c   --- paginated --- unnumbered ---
@c   **Lists (Unnumbered)
@c     ..Bibliography
@c     ..Tables
@c     ..Indices
@c %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%








@c %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@c BEGIN COPYING
@c %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


@copying

@c <------------------------------------->
@docbook
<para>Published by:</para>

<literallayout class="normal">Full Name
Address Line 1
Address Line 2
etc.
Email: <email>user@@example.com</email>
URL: <ulink url="http://www.example.com/">http://www.example.com/</ulink></literallayout>

<literallayout class="normal">Copyright &copy; YYYY, YYYY
Full name here
All Rights Reserved.</literallayout>
@end docbook
@c <------------------------------------->


@c <------------------------------------->
@ifnotdocbook
Copyright @copyright{} @value{COPYRIGHT} @*
@value{AUTHOR} @*
All Rights Reserved.
@end ifnotdocbook
@c <------------------------------------->


@sp 1
The @value{TITLE} is copyright
@copyright{} @value{COPYRIGHT} by @value{AUTHOR}. It is published under
the conditions of the GNU General Public License, version 3.
@sp 2
This is Edition @value{EDITION} of @cite{@value{TITLE}}.

@end copying

@c /////////////////////////////////////////////////////////////////////////////








@c %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@c BDGIN TITLEPAGE
@c %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


@titlepage

@c Uncomment this if it's ever printed as a real book(let).
@c @shorttitlepage @value{SHORTTITLE}

@title @value{TITLE}
@subtitle @value{UPDATE-MONTH}
@author @value{AUTHOR} @c Full Name here

@c <------------------------------------->
@ifnotdocbook
@c Include the Distribution inside the titlepage environment so
@c that headings are turned off.  Headings on and off do not work.

@page
@vskip 0pt plus 1filll
Published by:
@sp 1
@value{AUTHOR} @*
@value{ADDRESS1} @*
@value{ADDRESS2} @*
@* @c etc.
Email: @EMAIL{user@@example.com,user AT example.com} @*
URL: @url{http://www.example.com/} @*

@insertcopying
@end ifnotdocbook
@c <------------------------------------->

@end titlepage

@c /////////////////////////////////////////////////////////////////////////////








@c *****************************************************************************
@c HEADINGS
@c *****************************************************************************

@iftex
@headings off
@evenheading @thispage @| @value{DRAFT} @| @strong{@value{SHORTTITLE}}
@oddheading  @strong{@thischapter} @| @value{DRAFT} @| @thispage
@end iftex

@c /////////////////////////////////////////////////////////////////////////////








@c %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@c BEGIN TOP
@c --General Introduction
@c --Main Menu
@c --Table of Contents
@c %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%








@ifnottex
@ifnotdocbook
@ifnotxml

@c =============================================================================
@node Top
@top The CLOJURE Programming Language
@c =============================================================================

This  file documents  the programming  language CLOJURE,  and provides  example
source code that can be extracted and run.

@quotation
clojure: warning: Your terminal 'dumb' is not fully functional, expect some
problems.
@end quotation

@insertcopying
@end ifnotxml
@end ifnotdocbook
@end ifnottex




@c =============================================================================
@menu
@detailmenu
@end detailmenu
@end menu
@c =============================================================================




@c =============================================================================
@c @summarycontents
@contents
@c =============================================================================








@c *****************************************************************************

@c Add these to the menu if they ever get included.
@c @node Foreword
@c @unnumbered Foreword








@c *****************************************************************************

@node Preface
@unnumbered Preface

Text here.

@menu
* Audience::                    Who should read this @value{DOCUMENT}.
* Overview::                    An overview of the @value{DOCUMENT}.
* Conventions::                 Typographical conventions.
* Acknowledgements::            Acknowledgements.
@end menu




@c -----------------------------------------------------------------------------
@node Audience
@unnumberedsec Intended Audience

Audience text here.




@c -----------------------------------------------------------------------------
@node Overview
@unnumberedsec What Is Covered

Overview text and chapter by chapter description here.




@c -----------------------------------------------------------------------------
@node Conventions
@unnumberedsec Typographical Conventions

@c Copied mostly verbatim from the gawk manual.

@cindex Texinfo document formatting language
This @value{DOCUMENT} is written in an enhanced version of
@uref{http://www.gnu.org/software/texinfo/, Texinfo},
the GNU documentation formatting language.
A single Texinfo source file is used to produce both the printed and online
versions of a program's documentation.
@ifnotinfo
Because of this, the typographical conventions
are slightly different than in other books you may have read.
@end ifnotinfo

Examples you would type at the command-line are preceded by the common
shell primary and secondary prompts, @samp{$} and @samp{>}.  Input that
you type is shown @kbd{like this}.  Output from the command is preceded
by the glyph ``@print{}''.  This typically represents the command's
standard output.  Error messages, and other output on the command's
standard error, are preceded by the glyph ``@error{}''.  For example:

@example
$ @kbd{echo hi on stdout}
@print{} hi on stdout
$ @kbd{echo hello on stderr 1>&2}
@error{} hello on stderr
@end example

@ifnotinfo
In the text, command names appear in @code{this font}, while code segments
appear in the same font and quoted, @samp{like this}.  Options look
like this: @option{-f}.  Some things are emphasized @emph{like this},
and if a point needs to be made strongly, it is done @strong{like this}.
The first occurrence of a new term is usually its @dfn{definition} and
appears in the same font as the previous occurrence of ``definition''
in this sentence.  Finally, file names are indicated like this:
@file{/path/to/our/file}.
@end ifnotinfo




@c -----------------------------------------------------------------------------
@node Acknowledgements
@unnumberedsec Acknowledgements

Acknowledgements go here.




@c /////////////////////////////////////////////////////////////////////////////
@c END Preface








@c *****************************************************************************
@node Introduction
@chapter Introduction

CLOJURE's home page is at: @url{https://clojure.org/index}.

The home site describes CLOJURE as:

@quotation
Clojure is  a robust, practical,  and fast programming  language with a  set of
useful features that together form a simple, coherent, and powerful tool.

Clojure  is  a dynamic,  general-purpose  programming  language, combining  the
approachability and  interactive development  of a  scripting language  with an
efficient and robust infrastructure  for multithreaded programming.  Clojure is
a compiled language, yet remains completely dynamic –-- every feature supported
by Clojure is  supported at runtime.  Clojure provides easy  access to the Java
frameworks, with optional  type hints and type inference, to  ensure that calls
to Java can avoid reflection.

Clojure is a dialect of Lisp,  and shares with Lisp the code-as-data philosophy
and a powerful macro system.  Clojure is predominantly a functional programming
language,   and   features  a   rich   set   of  immutable,   persistent   data
structures.  When   mutable  state  is   needed,  Clojure  offers   a  software
transactional  memory  system and  reactive  Agent  system that  ensure  clean,
correct, multithreaded designs.

@end quotation

@heading Important Ideas

@itemize
@item Practical
@item General Purpose
@item Scripting Language
@item Multithreaded Programming
@item Compiled Language
@item Dynamic Language
@item Java Frameworks
@item Type Hints / Type Inference
@item Dialect of Lisp
@item Code-As-Data
@item Macro System
@item Immutable Data Structure
@item Transactional Memory System / Reactive Agent System
@end itemize




@c -----------------------------------------------------------------------------

@node Rationale for Clojure
@section Rationale for Clojure

@heading Rationale

CLOJURE provides the following features (benefits):

@itemize
@item it is LISP
@item it is FUNCTIONAL
@item symbiotic with the JVM
@item supports CONCURRENCY
@end itemize

@heading Rationale In Detail

@itemize
@item Stakeholders want the JVM

Customers and stakeholders have substantial investments in, and are comfortable
with the  performance, security  and stability of,  industry-standard platforms
like the JVM.

@item Stakeholders envy dynamic languages

Java developers @dots{} envy the  succinctness, flexibility and productivity of
dynamic languages;

@item Problems with concurrency

they face  ongoing problems dealing  with concurrency using native  threads and
locking.

@item Clojure addresses these concerns

Clojure is an effort in pragmatic  dynamic language design in this context.  It
endeavors to be  a general-purpose language suitable in those  areas where Java
is  suitable.  It  reflects the  reality that,  for the  concurrent programming
future, pervasive, unmoderated mutation simply has to go.

@item Clojure runs on the JVM

Clojure meets its  goals by: embracing an industry-standard,  open platform ---
the JVM;

@item CLOJURE is LISP

modernizes a venerable language - Lisp;

@item uses functional programming and immutable data

fosters  the functional  programming paradigm  with immutable,  persistent data
structures;

@item has concurrency support

and provides built-in  concurrency support  via software transactional  memory and
asynchronous agents.

@item CLOJURE IS:

robust --- practical --- fast

@end itemize




@c -----------------------------------------------------------------------------

@node Dynamic Functional Lisp
@section CLOJURE Is Dynamic Functional Lisp

CLOJURE is  a Lisp  not constrained  by backwards compatibility;  it is  also a
functional language supporting  immutability that is not  constrained by static
typing or homogeneous collections.

@itemize
@item
Extends the code-as-data paradigm to maps and vectors
@item
Defaults to immutability
@item
Core data structures are extensible abstractions
@item
Embraces a platform (JVM)
@item
Clojure is a functional language with a dynamic emphasis
@item
All data structures immutable & persistent, supporting recursion
@item
Heterogeneous collections, return types
@item
Dynamic polymorphism
@end itemize




@c -----------------------------------------------------------------------------

@node Clojure Features
@section Clojure Features
@cindex features

Clojure has a set of useful features that together form a simple, coherent, and
powerful tool.


@c .....................................

@node Dynamic Development
@subsection Dynamic Development
@cindex dynamic

First and foremost,  Clojure is dynamic.  That means that  a Clojure program is
not  just something  you compile  and  run, but  something with  which you  can
interact.  Almost all  of the language constructs are reified,  and thus can be
examined and changed.

This  leads to  a substantially  different experience  from running  a program,
examining its results  (or failures) and trying again.  In  particular, you can
grow your program, with data loaded,  adding features, fixing bugs, testing, in
an unbroken stream.

@subheading The REPL
@cindex REPL

While Clojure  can be embedded  in a Java application,  or used as  a scripting
language, the primary programming interface is the Read-Eval-Print-Loop (REPL).
You can  start the  Clojure REPL like  this, and then  follow along  trying the
samples in this feature tour:

@example
java -cp clojure.jar clojure.main
@end example

Clojure has arbitrary precision integers, strings, ratios, doubles, characters,
symbols, keywords.

@cindex compiler
@cindex JVM bytecode
While  Clojure is  a  compiled language,  you don't  ``run''  the compiler  ---
anything  you enter  into the  REPL or  load using  load-file is  automatically
compiled to JVM bytecode on the fly.


@c .....................................

@node Functional Programming
@subsection Functional Programming
@cindex functional

Clojure is  a functional programming language.  It:

@itemize
@item
provides the tools to avoid mutable state,
@item
provides  functions  as first-class  objects,  and
@item
emphasizes recursive iteration instead of side-effect based looping.
@end itemize

The philosophy  behind Clojure is  that most parts  of most programs  should be
functional, and that programs that are more functional are more robust.

@subheading First Class Functions
@cindex @code{fn}
@cindex @code{defn}
@cindex macro
@cindex function object

@code{fn} creates a function object.  It yields  a value like any other --- you
can store it in a var, pass it to functions etc.

@example
(def hello (fn [] "Hello world"))
@end example

@code{defn} is a macro that makes defining functions a little simpler.  Clojure
supports arity  overloading in  a single  function object,  self-reference, and
variable-arity functions using @code{&}:

@example
(defn argcount
  ([] 0)
  ([x] 1)
  ([x y] 2)
  ([x y & more] (+ (argcount x y) (count more))))
@end example

@cindex @code{let}
You can create local names for  values inside a function using @code{let}.  The
scope of any local names is lexical.

@subheading Immutable Data Structures
@cindex data structures, immutable
@cindex immutable data structures

The  easiest   way  to  avoid   mutating  state   is  to  use   immutable  data
structures.  Clojure provides a set of immutable

@itemize
@item lists,
@item vectors,
@item sets and
@item maps.
@end itemize

@cindex persistence
Since they can’t be changed, 'adding' or 'removing' something from an immutable
collection means creating a  new collection just like the old  one but with the
needed  change.  @dfn{Persistence}  is a  term  used to  describe the  property
wherein  the  old version  of  the  collection  is  still available  after  the
'change', and that the collection maintains its performance guarantees for most
operations.   Singly-linked  lists and  trees  are  the basic  functional  data
structures, to which  Clojure adds a hash  map, set and vector  both based upon
array mapped hash tries.

@subsubheading Metadata
@cindex metadata

Applications often need to associate attributes  and other data about data that
is  orthogonal to  the  logical value  of the  data.   Clojure provides  direct
support for  this metadata.   Symbols, and  all of  the collections,  support a
metadata map.   It can be accessed  with the meta function.   Metadata does not
impact equality semantics, nor will metadata be seen in operations on the value
of a collection.  Metadata can be read, and can be printed.

@subheading Extensible Abstractions
@cindex java interfaces

Clojure uses  Java interfaces to define  its core data structures.  This allows
for extensions of Clojure to  new concrete implementations of these interfaces,
and  the library  functions will  work  with these  extensions.  This  is a  big
improvement vs.  hardwiring a language  to the concrete implementations  of its
data types.

@subsubheading Seq Interface
@cindex seq interface

A good  example of this  is the  seq interface.  By  making the core  Lisp list
construct into  an abstraction, a wealth  of library functions are  extended to
any data  structure that can  provide a  sequential interface to  its contents.
All of  the Clojure data  structures can provide seqs.   Seqs can be  used like
iterators or generators.   Seqs are extremely simple,  providing a @code{first}
function,  which return  the  first item  in the  sequence,  and a  @code{rest}
function which returns the  rest of the sequence, which is  itself either a seq
or nil.

@subheading Recursive Looping

In the  absence of mutable local  variables, looping and iteration  must take a
different form than in languages with built-in for or while constructs that are
controlled by  changing state.  In  functional languages looping  and iteration
are replaced/implemented via recursive function calls.


@c .....................................

@node Dialect of Lisp
@subsection Dialect of Lisp
@cindex dialect of Lisp

Clojure  is a  member of  the  Lisp family  of languages.   Lisp’s approach  to
code-as-data and its macro system@footnote{The  macro system allows the compile
to be extended by user code.} still set it apart from other languages.  Clojure
extends the  code-as-data system beyond parenthesized  lists (s-expressions) to
vectors and  maps.  Thus  vectors and  maps can  be used  in macro  syntax, have
literal reader representations etc.

@heading The Reader and Macros

@cindex reader
Lisp  data, and  thus Lisp  code,  is read  by the  @dfn{reader}.@footnote{Most
Clojure programs begin life as text files, and  it is the task of the reader to
parse the text and  produce the data structure the compiler  will see.  This is
not  merely a  phase of  the  compiler.}  The  result  of reading  is the  data
structure represented by  the forms.  Clojure can compile  data structures that
represent code, and as part of that process it looks for calls to macros.  When
it sees  one, it calls  the macro, passing  the forms themselves  as arguments,
then uses  the return value of  the macro in  place of the macro  itself.  Thus
macros are functions that are called at compile time to perform transformations
of code.

@heading Syntactic Abstractions

Since code is  data, all of the  Clojure library is available to  assist in the
transformation.  Thus  macros allow  Lisps, and  Clojure, to  support syntactic
abstraction.  You  use macros  for the  same reasons you  use functions  --- to
eliminate repetition  in your code.   Macros should be reserved  for situations
for which functions are insufficient, e.g. when you need to control evaluation,
generate  identifiers etc.   Many of  the core  constructs of  Clojure are  not
built-in primitives but macros just like users can define.

@code{and} is a macro:

@example
(defmacro and
  ([] true)
  ([x] x)
  ([x & rest]
    `(let [and# ~x]
       (if and# (and ~@@rest) and#))))
@end example


@c .....................................

@node Runtime Polymorphism
@subsection Runtime Polymorphism

Systems  that   utilize  runtime   polymorphism  are   easier  to   change  and
extend. Clojure supports polymorphism in several ways:

@itemize
@item @emph{Java Interfaces}.
Most core infrastructure data structures in the Clojure runtime are defined by
Java interfaces.
@item @emph{Proxy}.
Clojure  supports  the generation  of  implementations  of Java  interfaces  in
Clojure using proxy
@item @emph{Multimethods}.
The  Clojure  language  supports  polymorphism  along  both  class  and  custom
hierarchies with multimethods.
@item @emph{Protocols}.
The Clojure language also supports a faster form of polymorphism with protocols.
@end itemize

@heading Multimethods
@cindex multimethods

Clojure  multimethods  are   a  simple  yet  powerful   mechanism  for  runtime
polymorphism that is free of the trappings of OO, types and inheritance.

@subheading Dispatch
@cindex dispatch
@cindex runtime polymorphism

The basic idea behind runtime polymorphism is that a single function designator
dispatches to  multiple independently-defined  function definitions  based upon
some  value of  the call.   For traditional  single-dispatch OO  languages that
value is the type of the 'receiver' or 'this'.

@subheading CLOS Functions
@cindex CLOS
@cindex multimethods

CLOS generic  functions extend  dispatch value  to a composite  of the  type or
value of multiple arguments, and are thus @dfn{multimethods}.

@subheading Arbitrary Function of Arguments
@cindex implementation inheritance

Clojure multimethods  go further still  to allow the  dispatch value to  be the
result of  an arbitrary  function of  the arguments.   Clojure does  not support
implementation inheritance.

@subheading Defining Multimethods
@cindex multimethods, defining
@cindex @code{defmulti}
@cindex @code{defmethod}

Multimethods are  defined using  @code{defmulti}, which takes  the name  of the
multimethod and the dispatch function.  Methods are independently defined using
@code{defmethod},  passing the  multimethod name,  the dispatch  value and  the
function body.

@heading Protocols
@cindex protocols

Similar to  interfaces, Clojure  protocols define only  function specifications
(no  implementation)   and  allow   types  to  implement   multiple  protocols.
Additionally,  protocols are  open to  later dynamic  extension for  new types.
Protocols are limited just  to dispatch on class type to  take advantage of the
native Java performance of polymorphic method calls.


@c .....................................

@node Concurrent Programming
@subsection Concurrent Programming
@cindex concurrent programming

Today’s systems  have to  deal with  many simultaneous  tasks and  leverage the
power of multi-core  CPUs. Doing so with  threads can be very  difficult due to
the   complexities  of   synchronization.  Clojure   simplifies  multi-threaded
programming in several ways.

@enumerate
@item Immutable Data.
Because the  core data  structures are  immutable, they  can be  shared readily
between threads.
@item State Changes.
However, it  is often necessary  to have state  change in a  program.  Clojure,
being a  practical language, allows state  to change but provides  mechanism to
ensure  that,  when  it  does  so, it  remains  consistent,  while  alleviating
developers from having to avoid conflicts manually using locks etc.
@item Software Transactional Memory System
The software transactional memory  system (STM), exposed through @code{dosync},
@code{ref},  @code{ref-set}, @code{alter},  et  al,  supports sharing  changing
state between threads in a synchronous and coordinated manner.
@item Agent System.
The  agent  system  supports  sharing  changing state  between  threads  in  an
asynchronous and independent manner.
@item Atoms System.
The  atoms  system  supports  sharing   changing  state  between  threads  in  a
synchronous and independent manner.
@item Dynamic Var System.
The  dynamic var  system, exposed  through @code{def},  @code{binding}, et  al,
supports isolating changing state within threads.
@item The Java Thread System.
IUn all cases, Clojure does not replace the Java thread system; rather it works
with it.  Clojure functions are @file{java.util.concurrent.Callable}U,
therefore they work with the @file{Executor} framework etc.
@item Refs.
Refs are  mutable references  to objects.   They can be  ref-set or  altered to
refer  to  different  objects  during  transactions,  which  are  delimited  by
@code{dosync} blocks.  All ref modifications within a transaction happen or none
do.

Also, reads  of refs within a  transaction reflect a snapshot  of the reference
world at  a particular point in  time, i.e.  each transaction  is isolated from
other  transactions.  If  a conflict  occurs between  2 transactions  trying to
modify the  same reference, one  of them will be  retried.  All of  this occurs
without explicit locking.
@end enumerate


@c .....................................

@node Hosted On The JVM
@subsection Hosted On The JVM

Clojure is designed to  be a hosted language, sharing the  JVM type system, GC,
threads etc.   It compiles all functions  to JVM bytecode.  Clojure  is a great
Java library  consumer, offering  the dot-target-member  notation for  calls to
Java.  Class names  can be referenced in full, or  as non-qualified names after
being imported.  Clojure supports the dynamic implementation of Java interfaces
and classes using reify and proxy:

Tapping into a Java class is as easy as:

@example
(import '[java.time LocalDate])

(defn add-week ^LocalDate [^LocalDate date]
  (.plusDays date 7))

(defn day->str [^LocalDate date]
  (format "%s %s, %s" (.getMonth date) (.getDayOfMonth date) (.getYear date)))

;; infinite sequence of weekly dates, starting from today
(def future-weeks (iterate add-week (LocalDate/now)))

(map day->str (take 4 future-weeks))
;; ("JULY 24, 2017" "JULY 31, 2017" "AUGUST 7, 2017" "AUGUST 14, 2017")
@end example




@c -----------------------------------------------------------------------------

@node Other Hosts
@section Other Hosts


@c .....................................

@node ClojureScript
@subsection ClojureScript
@cindex clojurescript

@url{https://clojurescript.org/, ClojureScript}

@cindex Google Closure optimizing compiler
ClojureScript  is a  compiler for  Clojure that  targets JavaScript.   It emits
JavaScript code which  is compatible with the advanced compilation  mode of the
Google Closure  optimizing compiler.  ClojureScript  combines the reach  of the
JavaScript platform,  the flexibility  and interactive development  of Clojure,
and  the whole-program  optimization  of  Google Closure  to  provide the  most
powerful language for programming the web.

@heading Why JavaScript?

The spread  of the browser and  web-based applications has given  JavaScript an
exclusive reach  unmatched by any  other language.  Because of  its importance,
JavaScript  engines  are also  receiving  extensive  research and  optimization
allowing  JavaScript to  compete  for performance  with  many more  established
platforms like the JVM.

@heading Why Google Closure?

As  the  purveyors   of  some  of  the  most   complicated  client-service  web
applications in use today, Google has  invested heavily in creating the Closure
library  and  Closure  compiler  which  work together  to  make  whole  program
optimization possible, yielding  programs that provide minimal  load times even
when using many libraries.


@c .....................................

@node Closure CLR
@subsection Closure CLR

@url{https://clojure.org/about/clojureclr, ClosureCLR}

@heading About

This  project is  a native  implementation of  Clojure on  the Common  Language
Runtime (CLR), the execution engine  of Microsoft’s .Net Framework.  ClojureCLR
is programmed in  C# (and Clojure itself) and makes  use of Microsoft’s Dynamic
Language Runtime (DLR).








@c *****************************************************************************

@node Getting Started
@chapter Getting Started
@cindex getting started




@c -----------------------------------------------------------------------------

@node New To Clojure
@section New To Clojure

New to Clojure  and not sure where to  start? Here are a few  good resources to
get you off on the right foot:

@itemize
@item
@url{https://changelog.com/posts/rich-hickeys-greatest-hits/,
Rich Hickey's Greatest Hits}

@item
@url{http://www.braveclojure.com/,
Clojure For The Brave And True}

@item
@url{http://aphyr.com/posts/301-clojure-from-the-ground-up-welcome,
Clojure From The Ground Up}

@xref{Clojure From The Ground Up}

@item
@url{http://4clojure.org/,
4Clojure (Learn Clojure Interactively)}

@item
@url{http://clojurescriptkoans.com/,
ClojureScript Koans}

@item
@url{https://repl.it/languages/clojure,
Run Clojure Code In Your Browser}

@end itemize




@c -----------------------------------------------------------------------------

@node CLI Guide
@section CLI Guide
@cindex CLI Guide

Clojure provides command line  tools that can be used to  start a Clojure repl,
use Clojure and Java libraries, and start Clojure programs.

@itemize
@item
Running an interactive REPL (Read-Eval-Print Loop)
@item
Running Clojure programs
@item
Evaluating Clojure expressions
@item
using Clojure and Java libraries
@end itemize


@c .....................................


@node Installing CLI Tools
@subsection Installing CLI Tools
@cindex install cli tools
@cindex command line tools
@cindex cli tools

@heading Initial Self-Configuration

After  installing Clojure  via  HomeBrew,  the first  time  I  ran the  command
@command{clojure} from Bash prompt, this occurred:

@verbatim
>>>[532]pine:Pine ~/Dev/Programming/Languages/Clojure
?clojure
Downloading: org/clojure/clojure/1.9.0/clojure-1.9.0.pom from https://repo1.maven.org/maven2/
Downloading: org/clojure/spec.alpha/0.1.143/spec.alpha-0.1.143.pom from https://repo1.maven.org/maven2/
Downloading: org/clojure/pom.contrib/0.2.2/pom.contrib-0.2.2.pom from https://repo1.maven.org/maven2/
Downloading: org/clojure/core.specs.alpha/0.1.24/core.specs.alpha-0.1.24.pom from https://repo1.maven.org/maven2/
Downloading: org/clojure/clojure/1.9.0/clojure-1.9.0.jar from https://repo1.maven.org/maven2/
Downloading: org/clojure/spec.alpha/0.1.143/spec.alpha-0.1.143.jar from https://repo1.maven.org/maven2/
Downloading: org/clojure/core.specs.alpha/0.1.24/core.specs.alpha-0.1.24.jar from https://repo1.maven.org/maven2/
Clojure 1.9.0
user=>
@end verbatim

@heading Leiningen Initialization

After installing Leiningen via HomeBrew, the first time I ran the command
@command{lein repl}, this occurred:

@verbatim
?lein repl
Retrieving org/clojure/tools.nrepl/0.2.12/tools.nrepl-0.2.12.pom from central
Retrieving org/clojure/pom.contrib/0.1.2/pom.contrib-0.1.2.pom from central
Retrieving org/sonatype/oss/oss-parent/7/oss-parent-7.pom from central
Retrieving clojure-complete/clojure-complete/0.2.4/clojure-complete-0.2.4.pom from clojars
Retrieving org/clojure/tools.nrepl/0.2.12/tools.nrepl-0.2.12.jar from central
Retrieving clojure-complete/clojure-complete/0.2.4/clojure-complete-0.2.4.jar from clojars
nREPL server started on port 60559 on host 127.0.0.1 - nrepl://127.0.0.1:60559
REPL-y 0.3.7, nREPL 0.2.12
Clojure 1.8.0
Java HotSpot(TM) 64-Bit Server VM 11+28
    Docs: (doc function-name-here)
          (find-doc "part-of-name-here")
  Source: (source function-name-here)
 Javadoc: (javadoc java-object-or-class-here)
    Exit: Control+D or (exit) or (quit)
 Results: Stored in vars *1, *2, *3, an exception in *e

user=>
@end verbatim


@c .....................................

@node Build Tools
@subsection Build Tools
@cindex build tools

Build  tools  provide  a  range  of capabilities  for  building,  running,  and
deploying  Clojure libraries  and applications.  The two  most popular  Clojure
build tools are

@itemize
@item @url{https://leiningen.org/, Leiningen}
@item @url{http://boot-clj.com/, Boot}
@end itemize


@c .....................................

@node Run a REPL
@subsection Run a REPL
@cindex REPL
@cindex run a Clojure REPL
@cindex run REPL
@cindex Clojure, run
@cindex @command{clj} tool

@heading REPL

After you download and  install the tools, you can start a  REPL by running the
@command{clj} tool:

@example
$ clj
Clojure 1.9.0
user=>
@end example

Once in the REPL  you can type Clojure expressions and  press enter to evaluate
them.


@c .....................................

@node Working With Deps
@subsection Working With Dependencies (Deps)
@cindex deps
@cindex dependencies
@cindex library
@cindex libraries, using
@cindex Java libraries
@cindex Maven ecosytem
@cindex Maven Central
@cindex program, run
@cindex Clojars

In  all the  above scenarios  you  might want  to  use other  Clojure and  Java
libraries (@dfn{dependencies} or  @dfn{deps}).  These may be  libraries you are
writing  locally, projects  in git  (e.g.  on GitHub)  or, commonly,  libraries
available in the Maven ecosystem and  hosted by central repositories like Maven
Central or Clojars.

In all cases, using a library involves:
@cindex how to use a library

@enumerate a
@item
specifying which library you want to  use, providing its name and other aspects
like version (using a @file{deps.edn} file)
@item
getting it (once) from the git or maven repositories to your local machine
@item
making it available on the JVM classpath so Clojure can find it while your REPL
or program is running
@end enumerate

@cindex @file{deps.edn}
Clojure tools specify a syntax and  file (@file{deps.edn}) for (a), given which
they’ll handle (b) and (c) automatically.

@heading Using A Clojure Or Java Library

There are  many Clojure  and Java  libraries available  that provide  access to
practically  any  functionality you  might  need.   For example,  consider  the
commonly used Clojure library @file{clj-time} for working with dates and times.

@subheading Declaring Dependencies
@cindex dependencies, declaring

To work with this  library, you need to declare it as a  dependency so the tool
can ensure it  has been downloaded and  added to the classpath.   The readme in
most projects shows  the name and version, such  as @code{[clj-time "0.14.2"]}.
Create a @file{deps.edn} file to declare the dependency:

@subsubheading @file{deps.edn}
@cindex @file{deps.edn}

@example
@{:deps
 @{clj-time @{:mvn/version "0.14.2"@}@}@}
@end example

Restart the REPL with the @command{clj} tool:

@example
$ clj
Downloading: clj-time/clj-time/0.14.2/clj-time-0.14.2.pom from https://clojars.org/repo/
Downloading: clj-time/clj-time/0.14.2/clj-time-0.14.2.jar from https://clojars.org/repo/
Clojure 1.9.0
user=> (require '[clj-time.core :as t])
nil
user=> (str (t/now))
"2017-12-06T19:36:56.159Z"
@end example

You will see messages about a library being downloaded the first time you use a
dependency.  Once the file is downloaded, it will be reused in the future.  You
can use  the same process to  add other libraries to  your @file{deps.edn} file
and explore Clojure or Java libraries.


@c .....................................

@node Write A Program With Deps
@subsection Write A Program Using A Dependency
@cindex deps
@cindex @file{deps.edn}
@cindex write program
@cindex program, write

@heading How To Create Hello World

Create a directory  @file{hello-world} and change to that  directory.  Copy the
@file{deps.edn} file into  this directory.  By default,  the @command{clj} tool
will  look  for  source  files  in the  @file{src}  directory,  so  create  the
@file{src} directory and declare your program at @file{src/hello.clj}:

@initial_setup
mkdir -p clj
@end initial_setup

@subheading @file{deps.edn} for Hello World

@(hello-world__deps.edn@)=
{:deps
  {clj-time {:mvn/version "0.4.2"}}}
@

@initial_setup
mkdir -p clj/hello-world
@end initial_setup

@post_create hello-world__deps.edn mv hello-world__deps.edn clj/hello-world/deps.edn

@subheading @file{src/hello.clj}

@initial_setup
mkdir -p clj/hello-world/src
mkdir -p clj/time-lib/src/
mkdir -p clj/hello-time/src
@end initial_setup

@(hello-world__hello.clj@)=
(ns hello
  (:require [clj-time.core :as t]
            [clj-time.format :as f]))

(defn time-str
  "Returns a string representation of a datetime in the local time zone."
  [dt]
  (f/unparse
    (f/with-zone (f/formatter "hh:mm aa") (t/default-time-zone))
    dt))

(defn -main []
  (println "Hello world, the time is" (time-str (t/now))))

@

@post_create hello-world__hello.clj mv hello-world__hello.clj clj/hello-world/src/hello.clj

@subheading Run Hello World

This program has  a static entry point named @code{-main}  that is suitable for
external invocation.  The @command{clj} tool acts as a Clojure program launcher
with the @option{-m} option, which specifies the namespace to run:

@example
$ clj -m hello
Hello world, the time is 02:04 PM
@end example

This  program can  be invoked  from the  command line  or via  a @command{make}
target @code{hello-world}.

@c _____________________________________

@node Makefile Target for Hello World
@appendixsubsubsec Makefile Target for Hello World

@<Makefile---Example Targets@>=
# HELLO WORLD
#############
.PHONY: hello-world

clj/hello-world/src/hello.clj : $(FILE).twjr
	jrtangle $(FILE).twjr

hello-world : clj/hello-world/src/hello.clj
	cd clj/hello-world && clj -m hello

@


@c .....................................

@node Using Local Libraries
@subsection Using Local Libraries
@cindex local libraries
@cindex local coordinates

You can move part  of this application into a library on  your local disk.  The
@command{clj} tool uses  local coordinates to support projects  that exist only
on your local disk.  Extract the  @file{clj-time} parts of this application out
into a library in a parallel directory @file{time-lib}.

@example
├── time-lib
│   ├── deps.edn
│   └── src
│       └── hello_time.clj
└── hello-time
    ├── deps.edn
    └── src
        └── hello.clj
@end example

@heading Library File @file{time-lib/src/hello_time.clj}

Under @file{time-lib}, use a copy of the @file{deps.edn} file you already have,
and create a file @file{src/hello_time.clj}:

@(time-lib__deps.edn@)=
{:deps
  {clj-time {:mvn/version "0.4.2"}}}

@

@post_create time-lib__deps.edn mv time-lib__deps.edn clj/time-lib/deps.edn

@(time-lib__hello_time.clj@)=
(ns hello-time
  (:require [clj-time.core :as t]
            [clj-time.format :as f]))

(defn now
  "Returns the current datetime"
  []
  (t/now))

(defn time-str
  "Returns a string representation of a datetime in the local time zone."
  [dt]
  (f/unparse
    (f/with-zone (f/formatter "hh:mm aa") (t/default-time-zone))
    dt))

@

@post_create time-lib__hello_time.clj mv time-lib__hello_time.clj clj/time-lib/src/hello_time.clj

@heading @file{hello-time__hello.clj}

Update the  application at @file{hello-world/src/hello.clj} to  use your library
instead (place the updated program in @file{hello-time/src}:

@(hello-time__hello.clj@)=
(ns hello
  (:require [hello-time :as ht]))

(defn -main []
  (println "Hello Time, the world is" (ht/time-str (ht/now))))

@

@post_create hello-time__hello.clj mv hello-time__hello.clj clj/hello-time/src/hello.clj

Modify @file{hello-world/deps.edn} to use a local coordinate that refers to the
root directory of the @file{time-lib} library (make sure to update the path for
your machine):

@(hello-time__deps.edn@)=
{:deps
 {time-lib {:local/root "../time-lib"}}}

@

@post_create hello-time__deps.edn mv hello-time__deps.edn clj/hello-time/deps.edn

You can  then test  everything from  the hello-world  directory by  running the
application:

@example
$ clj -m hello
Hello world, the time is 02:07 PM
@end example

@c _____________________________________

@node Makefile Hello Time Target
@appendixsubsubsec Makefile Hello Time Target

@<Makefile---Example Targets@>=
# HELLO TIME
############

.PHONY : hello-time

hello-time : clj/hello-time/src/hello.clj
	cd clj/hello-time && clj -m hello

clj/hello-time/src/hello.clj : $(FILE).twjr
	jrtangle $(FILE).twjr

@









@c *****************************************************************************

@node Resources
@chapter Resources
@cindex resources



@c -----------------------------------------------------------------------------

@node Community Resources
@section Community Resources
@cindex resources, community

@url{https://clojure.org/community/resources, Community Resources}


@c .....................................

@node Community Discussion
@subsection Community Discussion
@cindex resources, community discussion


@c .....................................

@node Community Tutorials
@subsection Community Tutorials
@cindex resources, tutorials
@cindex tutorials




@c -----------------------------------------------------------------------------

@node Learn Clojure
@section Learn Clojure
@cindex learn clojure

@url{https://clojure.org/guides/learn/syntax, Learn Clojure}




@c -----------------------------------------------------------------------------

@node Clojure From The Ground Up
@section Clojure From The Ground Up
@cindex from the ground up

@url{https://aphyr.com/posts/301-clojure-from-the-ground-up-welcome,
Clojure From The Ground Up}


@c .....................................

@node Welcome
@subsection Welcome To Clojure From The Ground Up
@cindex welcome

@heading Learn Functional Programming With Clojure

This book is about how to program.   This guide aims to introduce newcomers and
experienced programmers alike to the beauty of functional programming, starting
with the simplest  building blocks of software.  We’ll be  learning in Clojure,
which is a  modern dialect of a  very old family of  computer languages, called
Lisp.  @emph{By the end  of this series, you’ll have a  thorough command of the
Clojure programming language.}

@subheading What About Programming?

We’re going to explore the nature of syntax, metalanguages, values, references,
mutation,  control flow,  and concurrency.

@itemize
@item
syntax and its nature
@item
metalanguages
@item
values
@item
references
@item
mutation
@item
control flow
@item
concurrency
@end itemize

Many  languages leave  these ideas  implicit in  the language  construction, or
don’t have  a concept of  metalanguages or  concurrency at all.   Clojure makes
these ideas explicit, first-class language constructs.  At the same time, we’re
going  to  defer or  omit  any  serious  discussion  of static  type  analysis,
hardware, and performance.

@subheading What About Clojure?

In more  general terms, Clojure  is a  well-rounded language.  It  offers broad
library support and runs on multiple operating systems.  Clojure performance is
not  terrific,  but  is  orders  of magnitude  faster  than  Ruby,  Python,  or
Javascript.  Unlike  some faster  languages, Clojure  emphasizes safety  in its
type system  and approach  to parallelism,  making it  easier to  write correct
multithreaded  programs.  Clojure  is concise,  requiring very  little code  to
express complex  operations.  It offers a  REPL and dynamic type  system: ideal
for beginners to experiment with, and well-suited for manipulating complex data
structures.  A consistently designed standard  library and full-featured set of
core datatypes rounds out the Clojure toolbox.

@subheading Clojure's Drawbacks

Finally, there  are some drawbacks.   As a  compiled language, Clojure  is much
slower to start than a scripting language; this makes it unsuitable for writing
small  scripts  for interactive  use.   Clojure  is  also not  well-suited  for
high-performance numeric operations.   Though it is possible, you  have to jump
through hoops to achieve performance comparable  with Java.


@c .....................................

@node Some Preliminaries
@subsection Some Preliminaries

@table @b

@cindex @code{nil}
@item nil
@code{nil}  is  the most  basic  value  in  Clojure.  It  represents  emptiness,
nothing-doing, not-a-thing. The absence of information.

@cindex boolean
@cindex @code{true}
@cindex @code{false}
@cindex Lisp logical system
@item Booleans
@code{true}   and  @code{false}   are   a  pair   of   special  values   called
@dfn{Booleans}.  They mean exactly what you  think: whether a statement is true
or false.   @code{true}, @code{false}, and  @code{nil} form the three  poles of
the Lisp logical system.

@item Values
Values are the ``nouns'' of programming: @code{nil}, @code{true}, @code{0}, and
@code{"hi there!"} are all different types of values;

@cindex symbol
@item Symbols
But most  sentences aren’t just  about stating the  existence of a  thing; they
involve action.  We need verbs.

@verbatim
user=> inc
#<core$inc clojure.core$inc@6f7ef41c>
@end verbatim

This  is a  verb called  @code{inc} –  short for  ``increment''.  Specifically,
@code{inc}  is  a  @dfn{symbol}  which  points  to  a  verb:  @verb{|#<core$inc
clojure.core$inc@6f7ef41c>|}.   Symbols are  references to  other values.  When
Clojure evaluates a symbol, it looks up that symbol’s meaning.  Look up @code{inc}, and
you get @verb{|#<core$inc clojure.core$inc@6f7ef41c>|}.

@cindex quote
@item quote
Can we refer to the symbol itself, without looking up its meaning?

@verbatim
user=> 'inc
inc
@end verbatim

@cindex sentence
@cindex expression
@cindex statement
Yes. The single quote @kbd{'} escapes a sentence.  In programming languages, we
call  @dfn{sentences} @emph{expressions}  or @emph{statements}.   A quote  says
``Rather than evaluating this expression’s text, simply return the text itself,
unchanged.''  Quote  a symbol,  get a  symbol.  Quote a  number, get  a number.
Quote anything, and get it back exactly as it came in.

@item list
@cindex list
@cindex LISP

@verbatim
user=> '(1 2 3)
(1 2 3)
@end verbatim

A list  is new kind of  value, one surrounded by  parentheses.  LISP originally
stood for ``LISt Processing'', and lists are still at the core of the language.
In fact, they form the most basic  way to compose expressions, or sentences.  A
@dfn{list} is a single expression which has multiple parts.  For instance, this
list  contains three  elements: the  numbers  1, 2,  and 3.  Lists can  contain
anything: numbers, strings, even other lists.

@item sentence
But  let’s  try something  simpler.   Something  we  know  how to  talk  about.
``Increment the number zero.''  We have  a symbol for incrementing, and we know
how to write the number zero.  Let’s combine them in a list:

@verbatim
user=> '(inc 0)
(inc 0)
@end verbatim

@cindex sentence
@cindex expression
A basic  sentence.  Remember, since it’s  quoted, we’re talking about  the tree,
the text,  the expression, by itself.  Absent interpretation.  If we  remove the
single-quote, Clojure will interpret the expression:

@verbatim
user=> (inc 0)
1
@end verbatim

Incrementing zero yields one.  And if we wanted to increment that value?

@verbatim
user=> (inc (inc 0))
2
@end verbatim

@cindex sentence
A sentence in Lisp  is a list.  It starts with a verb,  and is followed by zero
or more objects for  that verb to act on.  Each part of  the list can itself be
another list, in  which case that nested  list is evaluated first,  just like a
nested clause in a  sentence.  Every list starts with a verb.   Parts of a list
are evaluated from  left to right.  Innermost lists are  evaluated before outer
lists.

@verbatim
(+ 1 (- 5 2) (+ 3 4))
(+ 1 3       (+ 3 4))
(+ 1 3       7)
11
@end verbatim

@cindex grammar
@item grammar
That’s it.  The  entire grammar of Lisp: the structure  for every expression in
the language.  We transform expressions  by substituting meanings  for symbols,
and obtain some result.

@cindex lambda calculus
@item Lambda Calculus
This is the  core of the Lambda  Calculus, and it is the  theoretical basis for
almost  all  computer languages.   All  languages  express  the text  of  their
programs  in   different  ways,  but   internally  all  construct  a   tree  of
expressions.  Lisp simply makes it explicit.

@end table


@c .....................................

@node Types
@subsection Types
@cindex type

We say that a @dfn{type} is a group of values which work in the same way.  It’s
a property that some  values share, which allows us to  organize the world into
sets of similar things.  Types also help  us verify that a program makes sense.
Types can overlap and intersect each other.  Other types completely subsume one
another.

Every language  has a type  system; a particular  way of organizing  nouns into
types, figuring out  which verbs make sense on which  types, and relating types
to  one another.  Some  languages are  strict, and  others  more relaxed.  Some
emphasize hierarchy, and others a more ad-hoc view of the world.

@heading Clojure's Type System Is Strong And Dynamic
@cindex strong type system
@cindex dynamic type system

We  call Clojure’s  type system  @emph{strong} in  that operations  on improper
types are simply not  allowed: the program will explode if  asked to subtract a
dandelion.  We  also say that  Clojure’s types are @emph{dynamic}  because they
are enforced when the program is run, instead of when the program is first read
by the computer.

Because Clojure is built  on top of Java, many of its types  are plain old Java
types.

@c _____________________________________

@node Integer Type
@subsubsection Integer Type
@cindex integer type
@cindex @file{java.lang.Long}
@cindex Long

@heading Long

Clojure's basic Integer type is a @file{java.lang.Long}, or ``Long'' for short.

@example
user=> (type 3)
java.lang.Long
@end example

@cindex signed two's complement representation
Longs, internally, are represented as a group of sixty-four binary digits (ones
and zeroes),  written down  in a particular  pattern called  @emph{signed two’s
complement representation}.

There are only two things to remember about Longs:

@enumerate
@item
Longs  use one  bit  to store  the  sign:  whether the  number  is positive  or
negative.

@item
@cindex MAX_VALUE
The other 63 bits represent the size of the number.  The biggest number you can
represent with a long  is: 2^^63 - 1 (called MAX_VALUE),  and the smallest long
is -2^^63.

@verbatim
user=> Long/MAX_VALUE
9223372036854775807
@end verbatim

@end enumerate

@heading Type Protection

What happens if you add one to the biggest Long?

@example
user=> (inc Long/MAX_VALUE)

ArithmeticException integer overflow
clojure.lang.Numbers.throwIntOverflow
(Numbers.java:1388)
@end example

@cindex integer overflow error
An error  occurs!  This is Clojure  telling us that something  went wrong.  The
type of error was an  @file{ArithmeticException}, and its message was ``integer
overflow'', meaning ``this type of number  can’t hold a number that big''.  The
error  came  from  a  specific  place  in  the  source  code  of  the  program:
@file{Numbers.java}, on line 1388.  That’s a part of the Clojure source code.

The  important thing  is that  Clojure’s type  system protected  us from  doing
something  dangerous;  instead  of  returning   a  corrupt  value,  it  aborted
evaluation and returned an error.

@heading BigInt
@cindex BigInt
@cindex @code{bigint}
@cindex arbitrary-precision integers

If you  do need  to talk about  really big  numbers, you can  use a  BigInt: an
arbitrary-precision integer.  Let’s convert the biggest Long into a BigInt, then
increment it:

@example
user=> (inc (bigint Long/MAX_VALUE))
9223372036854775808N
@end example

Notice  the  N at  the  end?   That’s  how Clojure  writes  arbitrary-precision
integers.

@example
user=> (type 5N)
clojure.lang.BigInt
@end example

@heading Integer, Short, And Byte

There are also smaller integers.

@example
user=> (type (int 0))
java.lang.Integer
user=> (type (short 0))
java.lang.Short
user=> (type (byte 0))
java.lang.Byte
@end example

@subheading Integer
@cindex Integer

Integers are half the size of Longs; they store values in 32 bits.
Their largest value is therefore 2^^31 - 1.

@subheading Short
@cindex Short

Shorts are 16 bits.  Largest value is 2^^15 - 1.

@subheading Byte
@cindex Byte

Bytes are 8 bits.  Largest value is 2^^7 - 1.

@subheading Largest Integer Values

@example
user=> Integer/MAX_VALUE
2147483647
user=> Short/MAX_VALUE
32767
user=> Byte/MAX_VALUE
127
@end example





@c *****************************************************************************

@node Clojure API Documentation
@chapter Clojure API Documentation
@cindex api

@url{https://clojure.org/api/api, Clojure API Documentation}

@heading Cheatsheet

@url{https://clojure.org/api/cheatsheet, Cheatsheet}

@heading ClojureDocs

@url{https://clojuredocs.org/, ClojureDocs}








@c ============================================================================
@c APPENDICES
@c =============================================================================








@c *****************************************************************************

@node First appendix
@appendix First Appendix Title

Some appendix here.






@c *****************************************************************************
@c                              THE MAKEFILE

@node The Makefile
@appendix The Makefile
@cindex makefile


@(Makefile@)=
# MAKEFILE FILE CHUNKS
######################

@<Makefile---Variable Definitions@>
@<Makefile---Default Target@>
@<Makefile---TWJR Targets@>
@<Makefile---Clean Targets@>
@<Makefile---Example Targets@>
@<Makefile---Applications@>

@




@c -----------------------------------------------------------------------------

@node Makefile Variable Definitions
@appendixsec Makefile Variable Definitions

The @env{SHELL} variable is included because some shell commands depend upon
Bash version 4, which is not native on my system.

The @env{ROOT} variable is designed to allow you to to extract the source files
(not the @acronym{TEXI}, @acronym{INFO}, @acronym{PDF} or @acronym{HTML} files,
but  the  programs defined  inside  the  @acronym{TWJR}  file) to  a  directory
structure outside of the your  ``present working directory'' (@env{PWD}) should
that be something you want to do, i.e., for production purposes.

The @code{FILE} variable  is the name of this source  @code{TWJR} file, without
extension.

The @code{FILES} variable is the name of  the root directory for the files that
are extracted during the @emph{tangling} phase.  This directory goes underneath
the @file{ROOT} directory.  Feel free to name this whatever you want.

The @code{LODESTONE}  variable is an empty  reference file that is  used solely
for its  modification time  to help  the Makefile  determine when  to recompile
(i.e., @emph{tangle} and @emph{weave}) the  source @file{TWJR} file.  It should
not be changed or otherwise touched (pun intended).

@<Makefile---Variable Definitions@>=
# VARIABLE DEFINITIONS
######################
LODESTONE := .lodestone

SHELL := /usr/local/bin/bash

FILE  := Clojure-Lang
ROOT  := $(PWD)
FILES := files

@




@c -----------------------------------------------------------------------------

@node Makefile Default Target
@appendixsec Default Target
@cindex default target

The @code{default} target  extracts all source files and moves  them into their
proper  directories,  and  processes  the   @code{TEXI}  source  file  into  an
@code{INFO}  file, a  @code{PDF} document,  and an  @code{HTML} web  site. This
process automatically updates the TEXI's nodes and sectioning commands prior to
generating  the   INFO,  PDF,  and   HTML  documents.    What  used  to   be  a
manually-intensive process is now completely  automated through a Makefile that
is extracted from the @code{TWJR}  source.

This  automated  process  depends   upon  the  programmer's  system  containing
@file{GNU   AWK}  (for   the   primary  literate   programming  operations   of
@emph{tangling}   and   @emph{weaving}@footnote{No  other   implementation   of
@file{AWK}  will  work}),   @file{make}  (to  control  the   build  and  output
processes@footnote{While I haven't tested it, just about any @file{make} should
work}),  @file{Texinfo} of  at least  version 6.5  (for the  processing of  the
@file{TEXI} output file), @file{makeinfo} (to produce the @file{INFO} file from
the @file{TEXI}  file), and @file{Emacs}  (for the automatic updating  of nodes
and sectioning  command@footnote{Again, while I  haven't tested it,  just about
any @file{Emacs}  should work}).   With these  dependencies, everything  can be
compiled with a single call to @command{make} with no argument:

@example
$ make
@end example

Individual files and documents can also be targeted with simple calls such as:

@example
$ make html

$ make openhtml

$ make pdf

$ make openpdf

$make info

$ make openinfo

$ make distclean

$ make allclean
@end example

@noindent and so forth (just name a few).

The target  @code{twjr} is  the default, and  does everything  explicitly.  The
target @code{weave}  (or alternatively @code{texi})  will run just  the command
@command{jrweave}  on the  @file{TWJR} file  to produce  the @file{TEXI}  file,
which  is  directly  responsible  for  producing  the  output  files.   If  the
@file{TWJR}  source  file has  been  modified,  then @command{maked}  will  run
@command{jrtangle} first to update all source documents.

@<Makefile---Default Target@>=
# DEFAULT Target
################
.PHONY : TWJR JRTANGLE TANGLE JRWEAVE WEAVE TEXI INFO PDF HTML
.PHONY : default twjr twjrkeep jrtangle tangle
.PHONY : jrweave weave texi info pdf html newmakefile

default : TWJR

@




@c -----------------------------------------------------------------------------

@node Makefile TWJR Targets
@appendixsec TWJR Targets
@cindex TWJR targets

These targets are all related to processing the main source @acronym{TWJR} file
in some  way. The @file{make} target  @command{twjr} is the default  target and
runs each of the processes  @command{jrtangle} and @command{jrweave} to produce
source files,  a @acronym{TEXI} file,  an @acronym{INFO} file,  a @acronym{PDF}
document, and an @acronym{HTML} web site.  It only sources what is necessary as
@file{make} is designed to do.  Note that at this time, @emph{weaving} includes
automatic  menu and  node  updating  of the  @acronym{TEXI}  file,  so that  an
@acronym{INFO} file  can also be  generated without needing to  manually update
the  @acronym{TEXI} file  first  as used  to be  the  case. @file{make}  target
@code{info}     runs     @command{makeinfo},     target     @code{pdf}     runs
@command{pdftexi2dvi}, and target @code{html} runs @command{makeinfo --html}.

The default @file{twjr} target deletes all extraneous build and log files prior
to finishing.   If you want  to retain  the build and  log files, then  run the
target @file{twjrkeep} instead.

The  file  @file{.lodestone}   is  used  to  set  a  reference   time  for  the
@acronym{TWJR} file,  so that  if the @acronym{TWJR}  file changes,  new source
documents will be generated; otherwise, it  will simply be left alone. In other
words, if @file{.lodestone}  is older than @file{.twjr},  then @file{.twjr} has
been modified, and it should be @emph{tangled} and @emph{woven} first.  If it is
newer, then @command{make} will not recompile.

Should the @file{Makefile}  portion of the @file{TWJR} be modified,  then it is
important to  obtain a fresh copy  of the @file{Makefile} prior  to running any
target; therefore,  use the target  @command{make newmakefile} first,  then run
any desired target.

@<Makefile---TWJR Targets@>=
# TWJR TARGETS
##############

# Process everything; don't remove any build or log files;
twjrkeep : jrtangle jrweave info pdf html

# Process everything; remove build files and logs.
TWJR : twjr
twjr : twjrkeep dirclean

# JRTANGLE depends upon the LODESTONE and the ROOT FILES directory;
# if either is missing or out of date, then JRTANGLE will be run to
# extract its files.
JRTANGLE : TANGLE
TANGLE   : jrtangle
jrtangle : tangle
tangle   : $(LODESTONE) $(ROOT)/$(FILES)
$(LODESTONE) : $(FILE).twjr
	@printf "${YELLOW}Tangling $(FILE)...${CLEAR}\n"
	@jrtangle $(FILE).twjr
	@touch $(LODESTONE)
	@printf "${GREEN}done tangling.${CLEAR}\n"

# Extracts the source files using jrtangle
$(ROOT)/$(FILES) :
	@jrtangle $(FILE).twjr
	@touch $(LODESTONE)

# Extracts the Makefile if necessary by tangling; everything else
# is thereafter deleted
newmakefile : $(LODESTONE)
	make allclean

# Extracts the TEXI, and updates the nodes and sections with a batch call to
# Emacs; it depends upon TWJR
JRWEAVE : WEAVE
WEAVE   : jrweave
jrweave : weave
weave : TEXI
TEXI  : texi
texi  : $(FILE).texi
$(FILE).texi : $(FILE).twjr
	@printf "${YELLOW}Weaving $(FILE)...${CLEAR}\n"
	@jrweave $(FILE).twjr > $(FILE).texi
	@printf "${GREEN}done weaving.${CLEAR}\n";
	@printf "${YELLOW}updating $(FILE)'s menus and nodes...${CLEAR}\n"
	@emacs --batch --eval '(progn (find-file "./$(FILE).texi" nil) \
	  (texinfo-master-menu 1) (save-buffer 0))' 2> batch.log
	@printf "${GREEN}done updating.${CLEAR}\n"

# Runs makeinfo on the TEXI file;
# Opens the INFO file in Emacs
INFO : info
info : $(FILE).info
$(FILE).info : $(FILE).texi
	@printf "${YELLOW}Creating an INFO file...${CLEAR}\n"
	@makeinfo $(FILE).texi
	@printf "${GREEN}done${CLEAR}\n"
openinfo : INFO
	@printf "${YELLOW}Opening INFO in Emacs...${CLEAR}\n"
	@emacsclient -s server --eval '(info "($(ROOT)/$(FILE).info)top")'
	@printf "${GREEN}done${CLEAR}\n"

# Runs pdftexi2dvi on the TEXI file;
# Opens the PDF file
PDF : pdf
pdf : $(FILE).pdf
$(FILE).pdf : $(FILE).texi
	@printf "${YELLOW}Creating a PDF file...${CLEAR}\n"
	@pdftexi2dvi --build=tidy --build-dir=build --quiet $(FILE).texi
	@printf "${GREEN}done${CLEAR}\n"
openpdf : PDF
	@printf "${YELLOW}Opening PDF...${CLEAR}\n"
	@open $(FILE).pdf
	@printf "${GREEN}done${CLEAR}\n"

# Runs makeinfo --html on the TEXI file;
# Opens index.html in a browser
HTML : html
html : $(FILE)/index.html
$(FILE)/index.html : $(FILE).texi
	@printf "${YELLOW}Creating an HTML directory...${CLEAR}\n"
	@makeinfo --html $(FILE).texi
	@printf "${GREEN}done${CLEAR}\n"
openhtml : HTML
	@printf "${YELLOW}Opening INDEX.HTML in the browser...${CLEAR}\n"
	@open $(FILE)/index.html
	@printf "${GREEN}done${CLEAR}\n"

@




@c -----------------------------------------------------------------------------

@node Makefile Clean Targets
@appendixsec Makefile Clean Targets
@cindex Makefile clean targets

The @command{clean} target removes  backup files. The @command{dirclean} target
removes build  directories and log  files, but  not source files  (those inside
@file{files} directory,  e.g., @file{bin/} and and  @file{src/}) and associated
files and  programs inside  them.  The  @command{distclean} target  removes the
@acronym{INFO}, @acronym{PDF},  @acronym{HTML}, and @acronym{source}  files and
directories, leaving just  the @file{TWJR} file, the @file{TEXI}  file, and the
@file{Makefile}.  Finally,  the  @command{allclean} target  removes  everything
except the @acronym{TWJR} file and the @file{Makefile}.

@<Makefile---Clean Targets@>=
.PHONY : clean dirclean distclean worldclean allclean

# remove backup files
clean :
	@printf "${WHITEBOLD}Cleaning...${CYAN}\n"
	@rm -f *~ .*~ #*#
	@printf "${GREEN}done cleaning.${CLEAR}\n"

# after clean: remove all build and miscellaneous files, leaving only
# TWJR, TEXI, INFO, HTML, PDF, Makefile & the source documents.
dirclean : clean
	@printf "${WHITEBOLD}Dir-cleaning...${CYAN}\n"
	@for file in *; do         \
	  case $$file in           \
	    $(FILE)* | Makefile) ;;\
	    $(FILES)*)	 	 ;;\
	    $(LODESTONE))        ;;\
	    *) rm -vfr $$file	 ;;\
	  esac                     \
	done
	@printf "${GREEN}done dir-cleaning.${CLEAR}\n"

# after dirclean: remove INFO, HTML, and PDF, and FILES
distclean : dirclean
	@printf "${WHITEBOLD}Dist-cleaning...${CYAN}\n"
	@rm -vfr $(FILE) $(FILE).info $(FILE).pdf $(ROOT)/$(FILES)
	@printf "${GREEN}done dist-cleaning.${CLEAR}\n"

# allclean: remove TEXI, leaving only TWJR and Makefile
allclean : distclean
	@printf "${WHITEBOLD}Cleaning all...${CYAN}\n"
	@rm -vfr $(FILE).texi
	@printf "${GREEN}done cleaning all.${CLEAR}\n"

@




@c -----------------------------------------------------------------------------

@node Makefile Example Targets
@appendixsec Makefile Example Targets
@cindex makefile example targets

@<Makefile---Example Targets@>=

@





@c -----------------------------------------------------------------------------

@node Makefile Applications
@appendixsec Makefile Applications
@cindex Makefile applications

Place any targets for running  code-specific commands here, such as executables
in the @file{bin/} directory.  The file @verb{|@<Makefile---Applicaionts@>|} is
a hook  that can  be used in  another part  of the source  document; this  is a
fundamental feature of literate programming.

@<Makefile---Applications@>=
@








@c *****************************************************************************
@node Code Chunk Summaries
@appendix Code Chunk Summaries

This @value{APPENDIX} presents alphabetical lists of
all the file definitions, the code chunk definitions,
and the code chunk references.

@menu
* File Definitions::          Source files by definition.
* Code Chunk Definitions::    Code chunks by definition.
* Code Chunk References::     Code chunks by reference.
@end menu




@c -----------------------------------------------------------------------------
@node File Definitions
@appendixsec Source File Definitions

@print_file_defs




@c -----------------------------------------------------------------------------
@node Code Chunk Definitions
@appendixsec Code Chunk Definitions

@print_code_defs




@c -----------------------------------------------------------------------------
@node Code Chunk References
@appendixsec Code Chunk References

@print_code_refs







@c *****************************************************************************
@c                                BIBLIOGRAPHY

@node @mybibnode{}
@unnumbered Bibliography

@table @asis

@mybibitem{Nada}
Nothing

@end table






@c *****************************************************************************

@node List of Tables
@unnumbered List of Tables

@listoffloats Table








@c  *****************************************************************************
@node Concept Index
@unnumbered Index

@printindex cp

@bye

TODO:
